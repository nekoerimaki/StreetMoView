<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 100vw;
            overflow: hidden;
        }

        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 10px 20px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .dropdown-container {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: white;
            min-width: 250px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            padding: 10px;
            border-radius: 8px;
            flex-direction: column;
            gap: 10px;
        }

        .dropdown-content.show {
            display: flex;
        }

        .dropdown-content input[type="text"] {
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .dropdown-content button {
            width: 100%;
        }

        .input-group, .action-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-groups {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header-links {
            display: flex;
            align-items: center;
            gap: 15px;
            white-space: nowrap;
        }

        #speed-input, #interval-input {
            width: 80px;
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 15px;
            font-size: 0.9rem;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            white-space: nowrap;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #split-container {
            display: flex;
            flex-grow: 1;
            position: relative;
        }

        #map, #street-view {
            height: 100%;
            transition: flex 0.3s ease;
            position: relative;
        }

        #street-view {
            flex-grow: 0.7;
            flex-basis: 70%;
        }

        #map {
            flex-grow: 0.3;
            flex-basis: 30%;
        }

        .splitter {
            width: 8px;
            background-color: #bdc3c7;
            cursor: col-resize;
            z-index: 2;
        }

        #message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #e74c3c;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .mode-switcher {
            display: flex;
            border: 2px solid #3498db;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-switcher button {
            background-color: white;
            color: #3498db;
            padding: 8px 12px;
            border-radius: 0;
            box-shadow: none;
            transition: background-color 0.2s, color 0.2s;
        }

        .mode-switcher button.active {
            background-color: #3498db;
            color: white;
        }

        #info-display {
            background-color: #2c3e50;
            color: white;
            padding: 5px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px 25px;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .info-label {
            font-weight: bold;
            color: #bdc3c7;
        }
        .info-value {
            font-size: 1.1rem;
        }

        #lang-switcher {
            display: flex;
            gap: 5px;
        }
        .lang-btn {
            padding: 5px 10px;
            font-size: 0.8rem;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: none;
            transform: none;
        }
        .lang-btn:hover {
            background-color: #bdc3c7;
            transform: none;
        }
        .lang-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .header-links a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .header-links a:hover {
            text-decoration: underline;
        }

        /* Responsive design for mobile */
        @media (max-width: 767px) {
            .controls-area {
                padding: 10px;
                flex-direction: column;
                align-items: flex-start;
            }

            .input-group, .action-group {
                flex-direction: column;
                gap: 5px;
                width: 100%;
            }

            .input-group label {
                width: 100%;
                text-align: left;
            }

            #origin-input, #destination-input, #speed-input, #interval-input, button {
                width: 100%;
            }
            .dropdown-content {
                min-width: auto;
                width: 100%;
            }

            #split-container {
                flex-direction: column;
            }

            #street-view, #map {
                flex-basis: auto;
                height: 50%;
                width: 100%;
            }

            .splitter {
                height: 8px;
                width: 100%;
                cursor: row-resize;
            }
            .mode-switcher {
                width: 100%;
            }

            #info-display {
                gap: 10px;
                padding: 10px;
                justify-content: center;
            }
            .info-item {
                flex-basis: 45%;
                align-items: flex-start;
            }
        }

        #elevation-chart-container {
            width: 100%;
            height: 100px;
            background-color: #2c3e50;
            padding: 5px 20px;
            box-sizing: border-box;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none; /* Initially hidden */
        }

        #elevation-chart {
            width: 100%;
            height: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div class="controls-area">
            <div class="control-groups">
                <div class="dropdown-container">
                    <button id="route-settings-button" data-i18n="routeSettings">経路設定</button>
                    <div class="dropdown-content" id="route-settings-dropdown">
                        <input type="text" id="origin-input" placeholder="出発地: 例. 東京駅" data-i18n-placeholder="originPlaceholder">
                        <input type="text" id="destination-input" placeholder="目的地: 例. 渋谷スクランブル交差点" data-i18n-placeholder="destinationPlaceholder">
                        <div class="mode-switcher">
                            <button id="driving-mode-btn" data-mode="DRIVING" class="active" data-i18n="driving">自動車</button>
                            <button id="bicycling-mode-btn" data-mode="BICYCLING" data-i18n="bicycling">自転車</button>
                            <button id="walking-mode-btn" data-mode="WALKING" data-i18n="walking">徒歩</button>
                        </div>
                        <label for="interval-input" data-i18n="interpolationInterval">補間間隔 (m):</label>
                        <input type="number" id="interval-input" value="5" min="1" max="100">
                        <button id="route-button" data-i18n="searchRoute">経路を検索</button>
                        <button id="load-gpx-button" data-i18n="loadGpx">GPXを読み込む</button>
                    </div>
                    <input type="file" id="gpx-file-input" accept=".gpx" style="display: none;">
                </div>
                <div class="action-group">
                    <label for="speed-input" data-i18n="speed">速度 (km/時):</label>
                    <input type="number" id="speed-input" value="0" min="1" max="60">
                    <button id="toggle-tour-button" disabled data-i18n="startTour">ツアー開始</button>
                    <button id="ble-connect-button" data-i18n="connectPower">パワーソースに接続</button>
                    <button id="hr-connect-button" data-i18n="connectHr">心拍計に接続</button>
                    <button id="log-toggle-button" data-i18n="startLog">ログ開始</button>
                </div>
            </div>
            <div class="header-links">
                <div id="lang-switcher">
                    <button data-lang="ja" class="lang-btn active">日本語</button>
                    <button data-lang="en" class="lang-btn">English</button>
                </div>
                <a href="https://github.com/nekoerimaki/StreetMoView" target="_blank" rel="noopener noreferrer">
                    Source Code
                </a>
            </div>
        </div>
        <div id="info-display">
            <div class="info-item">
                <span class="info-label" data-i18n="distTraveled">移動距離</span>
                <span class="info-value" id="dist-traveled">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="totalDist">経路全体</span>
                <span class="info-value" id="total-dist">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeElapsed">移動時間</span>
                <span class="info-value" id="time-elapsed">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeRemaining">残り時間</span>
                <span class="info-value" id="time-remaining">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="elevation">標高</span>
                <span class="info-value" id="elevation">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="gradient">勾配</span>
                <span class="info-value" id="gradient">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="power">パワー</span>
                <span class="info-value" id="power-display">0 W</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="cadence">ケイデンス</span>
                <span class="info-value" id="cadence-display">0 rpm</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="heartRate">心拍数</span>
                <span class="info-value" id="hr-display">0 bpm</span>
            </div>
        </div>
        <div id="elevation-chart-container">
            <canvas id="elevation-chart"></canvas>
        </div>
        <div id="split-container">
            <div id="street-view"></div>
            <div class="splitter" id="splitter"></div>
            <div id="map"></div>
        </div>
    </div>
    <div id="message-box"></div>

    <script>
        const GOOGLE_MAPS_API_KEY = 'AIzaSyC7uCB2u3BM1kA2xr-qiyrLTHjOrZfIKdo';

        const uiStrings = {
            ja: {
                routeSettings: '経路設定',
                originPlaceholder: '出発地: 例. 東京駅',
                destinationPlaceholder: '目的地: 例. 渋谷スクランブル交差点',
                driving: '自動車',
                bicycling: '自転車',
                walking: '徒歩',
                interpolationInterval: '補間間隔 (m):',
                searchRoute: '経路を検索',
                loadGpx: 'GPXを読み込む',
                speed: '速度 (km/時):',
                startTour: 'ツアー開始',
                stopTour: 'ツアー停止',
                connectPower: 'パワーソースに接続',
                connectHr: '心拍計に接続',
                disconnect: '接続解除',
                startLog: 'ログ開始',
                stopLog: 'ログ終了',
                distTraveled: '移動距離',
                totalDist: '経路全体',
                timeElapsed: '移動時間',
                timeRemaining: '残り時間',
                elevation: '標高',
                gradient: '勾配',
                power: 'パワー',
                cadence: 'ケイデンス',
                heartRate: '心拍数',
                startPoint: '出発地',
                endPoint: '目的地',
                currentLocation: '現在地',
                // messages
                noStreetView: 'この経路のストリートビューデータが見つかりませんでした。',
                routeFound: '経路が見つかりました！巡回を開始できます。',
                elevationProcessed: '経路の標高データを補正しました。',
                elevationError: '標高データの取得または補正に失敗しました。',
                originDestRequired: '出発地と目的地を入力してください。',
                invalidInterval: '有効な補間間隔を入力してください。',
                routeSearchFailed: '経路検索に失敗しました: ',
                routeNotFound: '経路が見つかりませんでした。場所を確認してください。',
                gpxNoTrackpoints: 'GPXファイルにトラックポイントが見つかりませんでした。',
                gpxNoCoordinates: 'GPXファイルから有効な座標を抽出できませんでした。',
                gpxParseError: 'GPXファイルの解析中にエラーが発生しました。',
                destinationReached: '目的地に到達しました。',
                noRouteForTour: 'まず経路を検索するかGPXファイルを読み込んでください。',
                invalidSpeed: '有効な速度を入力してください。',
                searchingDevice: 'デバイスを検索中です...',
                connectingDevice: 'デバイスに接続中です...',
                gattConnected: 'GATTサーバーに接続しました。',
                ftmsConnected: 'FTMSデバイスに接続しました。',
                btConnectionFailed: 'Bluetooth接続に失敗しました:',
                btConnectionError: 'Bluetooth接続エラー: ',
                deviceDisconnected: 'デバイスから切断しました。',
                searchingHr: '心拍計を検索中です...',
                connectingHr: '心拍計に接続中です...',
                hrConnected: '心拍計に接続しました。',
                hrConnectionFailed: '心拍計の接続に失敗しました:',
                hrConnectionError: '心拍計接続エラー: ',
                hrDisconnected: '心拍計から切断しました。',
                logStarted: 'ログ記録を開始しました。',
                logStopped: 'ログ記録を終了しました。',
                confirmSaveTcx: '記録したアクティビティをTCXファイルとして保存しますか？',
                powerZeroStop: 'パワーが0Wになりました。ツアーを停止します。',
                powerDetectedStart: 'パワーを検出。ツアーを開始します。',
            },
            en: {
                routeSettings: 'Route Settings',
                originPlaceholder: 'Origin: e.g., Tokyo Station',
                destinationPlaceholder: 'Destination: e.g., Shibuya Crossing',
                driving: 'Driving',
                bicycling: 'Bicycling',
                walking: 'Walking',
                interpolationInterval: 'Interval (m):',
                searchRoute: 'Search Route',
                loadGpx: 'Load GPX',
                speed: 'Speed (km/h):',
                startTour: 'Start Tour',
                stopTour: 'Stop Tour',
                connectPower: 'Connect Power Source',
                connectHr: 'Connect Heart Rate',
                disconnect: 'Disconnect',
                startLog: 'Start Logging',
                stopLog: 'Stop Logging',
                distTraveled: 'Distance Traveled',
                totalDist: 'Total Distance',
                timeElapsed: 'Time Elapsed',
                timeRemaining: 'Time Remaining',
                elevation: 'Elevation',
                gradient: 'Gradient',
                power: 'Power',
                cadence: 'Cadence',
                heartRate: 'Heart Rate',
                startPoint: 'Start Point',
                endPoint: 'End Point',
                currentLocation: 'Current Location',
                // messages
                noStreetView: 'Street View data could not be found for this route.',
                routeFound: 'Route found! You can start the tour.',
                elevationProcessed: 'Route elevation data has been processed.',
                elevationError: 'Failed to get or process elevation data.',
                originDestRequired: 'Please enter an origin and destination.',
                invalidInterval: 'Please enter a valid interpolation interval.',
                routeSearchFailed: 'Directions request failed due to: ',
                routeNotFound: 'Route not found. Please check the locations.',
                gpxNoTrackpoints: 'No trackpoints found in the GPX file.',
                gpxNoCoordinates: 'Could not extract valid coordinates from the GPX file.',
                gpxParseError: 'An error occurred while parsing the GPX file.',
                destinationReached: 'You have reached your destination.',
                noRouteForTour: 'Please search for a route or load a GPX file first.',
                invalidSpeed: 'Please enter a valid speed.',
                searchingDevice: 'Searching for device...',
                connectingDevice: 'Connecting to device...',
                gattConnected: 'Connected to GATT Server.',
                ftmsConnected: 'Connected to FTMS device.',
                btConnectionFailed: 'Bluetooth connection failed:',
                btConnectionError: 'Bluetooth connection error: ',
                deviceDisconnected: 'Disconnected from device.',
                searchingHr: 'Searching for heart rate monitor...',
                connectingHr: 'Connecting to heart rate monitor...',
                hrConnected: 'Connected to heart rate monitor.',
                hrConnectionFailed: 'Failed to connect to heart rate monitor:',
                hrConnectionError: 'Heart rate monitor connection error: ',
                hrDisconnected: 'Disconnected from heart rate monitor.',
                logStarted: 'Log recording started.',
                logStopped: 'Log recording stopped.',
                confirmSaveTcx: 'Do you want to save the recorded activity as a TCX file?',
                powerZeroStop: 'Power is 0W. Stopping the tour.',
                powerDetectedStart: 'Power detected. Starting the tour.',
            }
        };
        let currentLang = 'ja';

        /**
         * メッセージボックスにメッセージを表示します。
         * @param {string} message - 表示するメッセージ
         * @param {boolean} isError - エラーメッセージかどうか
         */
        function showMessage(message, isError = true) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.style.backgroundColor = isError ? '#e74c3c' : '#27ae60';
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.opacity = '1';
            }, 10);
            setTimeout(() => {
                messageBox.style.opacity = '0';
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 500);
            }, 3000);
        }

        /**
         * 経路全体の標高グラフを描画します。
         * @param {number} currentDistance - 現在の移動距離 (m)
         */
        function drawElevationChart(currentDistance = 0) {
            // グラフ描画に必要なデータが揃っているか確認
            const container = document.getElementById('elevation-chart-container');
            if (routeElevations.length < 2 || routeGradients.length < 2) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';

            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');

            // 高DPIディスプレイに対応
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            ctx.clearRect(0, 0, width, height);

            // 標高データの範囲を計算
            const minElev = Math.min(...routeElevations);
            const maxElev = Math.max(...routeElevations);
            const elevRange = maxElev - minElev;

            // 勾配データの範囲を計算（0%を中心に上下対称にすると見やすい）
            const minGrad = Math.min(...routeGradients);
            const maxGrad = Math.max(...routeGradients);
            const absMaxGrad = Math.max(Math.abs(minGrad), Math.abs(maxGrad), 2); // 最小でも±2%の範囲を確保
            const gradRange = absMaxGrad * 2;

            const padding = { top: 15, bottom: 30, left: 40, right: 40 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // 座標計算用のヘルパー関数
            const getX = (dist) => padding.left + (dist / totalDistance) * chartWidth;
            const getElevY = (elev) => padding.top + chartHeight - ((elev - minElev) / (elevRange || 1)) * chartHeight;
            const getGradY = (grad) => padding.top + chartHeight - ((grad - (-absMaxGrad)) / (gradRange || 1)) * chartHeight;

            // --- グラフの描画 ---

            // 1. 勾配グラフの0%基準線
            ctx.beginPath();
            const zeroY = getGradY(0);
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(width - padding.right, zeroY);
            ctx.strokeStyle = 'rgba(243, 156, 18, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. 標高グラフ（エリア）
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(52, 152, 219, 0.3)');
            gradient.addColorStop(1, 'rgba(44, 62, 80, 0.1)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.lineTo(getX(totalDistance), height - padding.bottom);
            ctx.lineTo(getX(0), height - padding.bottom);
            ctx.closePath();
            ctx.fill();

            // 3. 勾配グラフ（線）
            ctx.beginPath();
            ctx.moveTo(getX(0), getGradY(routeGradients[0]));
            for (let i = 1; i < routeGradients.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getGradY(routeGradients[i]));
            }
            ctx.strokeStyle = 'rgba(243, 156, 18, 0.8)'; // オレンジ色
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // 4. 標高グラフ（線）
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 5. 横軸の目盛りとラベルを描画
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(189, 195, 199, 0.2)'; // #bdc3c7 with alpha
            ctx.lineWidth = 1;
            ctx.font = '9px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#bdc3c7';

            const tickInterval = 500; // 500mごと
            for (let dist = tickInterval; dist < totalDistance; dist += tickInterval) {
                const x = getX(dist);
                ctx.moveTo(x, height - padding.bottom);
                ctx.lineTo(x, height - padding.bottom + 4); // 4pxの短い線

                const distKm = (dist / 1000);
                const label = distKm % 1 === 0 ? distKm.toFixed(0) : distKm.toFixed(1);
                ctx.fillText(label, x, height - padding.bottom + 15);
            }
            ctx.stroke();

            // 6. 軸ラベルの描画
            ctx.fillStyle = '#bdc3c7';
            ctx.font = '10px Inter';
            // 左側：標高
            ctx.textAlign = 'right';
            ctx.fillText(`${maxElev.toFixed(0)} m`, padding.left - 5, padding.top + 5);
            ctx.fillText(`${minElev.toFixed(0)} m`, padding.left - 5, height - padding.bottom);
            // 右側：勾配
            ctx.fillStyle = 'rgba(243, 156, 18, 0.9)';
            ctx.textAlign = 'left';
            ctx.fillText(`${absMaxGrad.toFixed(1)} %`, width - padding.right + 5, getGradY(absMaxGrad) + 3);
            ctx.fillText(`${(-absMaxGrad).toFixed(1)} %`, width - padding.right + 5, getGradY(-absMaxGrad) + 3);

            // 7. 現在地マーカー
            if (currentDistance > 0 && currentDistance < totalDistance) {
                const markerX = getX(currentDistance);
                const markerY = getElevY(routeElevations[currentPointIndex]);
                ctx.beginPath();
                ctx.moveTo(markerX, padding.top);
                ctx.lineTo(markerX, height - padding.bottom);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(markerX, markerY, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        /**
         * 標高データのスパイク（異常値）を除去するためにメディアンフィルタを適用します。
         * これにより、APIから返される稀な外れ値が勾配計算に与える影響を抑制します。
         * @param {Array<Object>} pointsData - 'elevation'プロパティを持つオブジェクトの配列
         * @param {number} windowSize - フィルタのウィンドウサイズ（3以上の奇数を推奨）
         * @returns {Array<Object>} - フィルタリングされた標高データを持つ新しい配列
         */
        function applyMedianFilter(pointsData, windowSize) {
            if (windowSize % 2 === 0 || windowSize < 3 || pointsData.length < windowSize) {
                return pointsData; // フィルタを適用できない場合は元のデータを返す
            }
            const filteredPoints = [];
            const halfWindow = Math.floor(windowSize / 2);

            for (let i = 0; i < pointsData.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(pointsData.length - 1, i + halfWindow);
                const windowSlice = pointsData.slice(start, end + 1);
                const elevations = windowSlice.map(p => p.elevation).sort((a, b) => a - b);
                const medianElevation = elevations[Math.floor(elevations.length / 2)];
                filteredPoints.push({ ...pointsData[i], elevation: medianElevation });
            }
            return filteredPoints;
        }

        /**
         * 2つの緯度/経度座標間の距離をメートル単位で計算します。
         * @param {google.maps.LatLng} p1 - 最初の座標
         * @param {google.maps.LatLng} p2 - 2番目の座標
         * @returns {number} - 2点間の距離（メートル）
         */
        function getDistance(p1, p2) {
            const R = 6371e3;
            const φ1 = p1.lat() * Math.PI / 180;
            const φ2 = p2.lat() * Math.PI / 180;
            const Δφ = (p2.lat() - p1.lat()) * Math.PI / 180;
            const Δλ = (p2.lng() - p1.lng()) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        /**
         * 2点間で補間された緯度/経度座標を計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @param {number} fraction - 補間率 (0-1)
         * @returns {google.maps.LatLng} - 補間された座標
         */
        function interpolate(from, to, fraction) {
            const lat = from.lat() + (to.lat() - from.lat()) * fraction;
            const lng = from.lng() + (to.lng() - from.lng()) * fraction;
            return new google.maps.LatLng(lat, lng);
        }

        /**
         * 2点間の進行方向（ヘディング）を度単位で計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @returns {number} - 進行方向（度）
         */
        function getHeading(from, to) {
            if (from.lat() === to.lat() && from.lng() === to.lng()) {
                return 0;
            }

            const lat1 = from.lat() * Math.PI / 180;
            const lon1 = from.lng() * Math.PI / 180;
            const lat2 = to.lat() * Math.PI / 180;
            const lon2 = to.lng() * Math.PI / 180;

            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let heading = Math.atan2(y, x) * 180 / Math.PI;

            heading = (heading + 360) % 360;
            return heading;
        }

        /**
         * 秒数を hh:mm:ss 形式にフォーマットします。
         * @param {number} seconds - 秒数
         * @returns {string} - フォーマットされた時間文字列
         */
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        /**
         * UI上の情報を更新します。
         */
        function updateInfoDisplay() {
            const totalDistanceKm = (totalDistance / 1000).toFixed(2);
            const distanceTraveledKm = (distanceTraveled / 1000).toFixed(2);
            const timeElapsed = totalTimeElapsed + (Date.now() - tourStartTime) / 1000;

            const remainingDistance = Math.max(0, totalDistance - distanceTraveled);
            const speedKmH = parseFloat(document.getElementById('speed-input').value);
            let timeRemaining = 0;
            if (speedKmH > 0) {
                timeRemaining = (remainingDistance / 1000) / speedKmH * 3600;
            }

            document.getElementById('total-dist').textContent = `${totalDistanceKm} km`;
            document.getElementById('dist-traveled').textContent = `${distanceTraveledKm} km`;
            document.getElementById('time-elapsed').textContent = formatTime(timeElapsed);
            document.getElementById('time-remaining').textContent = formatTime(timeRemaining);

            if (routeElevations.length > 0 && currentPointIndex < routeElevations.length && cumulativeDistances.length > currentPointIndex) {
                const currentElevation = routeElevations[currentPointIndex];
                document.getElementById('elevation').textContent = `${currentElevation.toFixed(1)} m`;

                // 現在地が属するサンプリング区間の勾配を計算する
                if (sampledPointsData.length >= 2) {
                    const currentDistance = cumulativeDistances[currentPointIndex];

                    // 現在地がどのサンプリング区間にいるかを探す
                    let segmentIndex = 0;
                    while (segmentIndex < sampledPointsData.length - 2 && currentDistance >= sampledPointsData[segmentIndex + 1].distance) {
                        segmentIndex++;
                    }

                    const startSample = sampledPointsData[segmentIndex];
                    const endSample = sampledPointsData[segmentIndex + 1];

                    const segmentDistance = endSample.distance - startSample.distance;
                    const elevationChange = endSample.elevation - startSample.elevation;

                    // 勾配計算の安定化：走行中の区間が計算に十分な長さを持つ場合のみ、勾配を更新する。
                    // 短い区間では、直前の有効な勾配の値を維持することで、異常なスパイクを防ぐ。
                    const MIN_GRADIENT_DISTANCE = 1.0; // 勾配計算に使用する最小距離(m)

                    if (segmentDistance >= MIN_GRADIENT_DISTANCE) {
                        currentGradient = (elevationChange / segmentDistance) * 100;
                    }
                } else {
                    currentGradient = 0; // サンプリングデータが不十分な場合
                }
                document.getElementById('gradient').textContent = `${currentGradient.toFixed(1)} %`;
            } else {
                 document.getElementById('elevation').textContent = `N/A`;
                 document.getElementById('gradient').textContent = `N/A`;
                 currentGradient = 0;
            }

            // グラフを更新
            drawElevationChart(distanceTraveled);
        }

        let map, panorama;
        let directionsService, directionsRenderer, elevationService, streetViewService;
        let routePoints = [];
        let routeGradients = [];
        let routeElevations = [];
        let gpxRoutePolyline = null;
        let cumulativeDistances = [];
        let sampledPointsData = [];
        let tourTimerId;
        let currentLocationMarker;
        let isTourRunning = false;
        let currentPointIndex = 0;
        let startMarker, endMarker;
        let totalDistance = 0;
        let distanceTraveled = 0;
        let tourStartTime = 0;
        let totalTimeElapsed = 0;
        let currentGradient = 0;
        let currentTourSpeedKmH = 0;
        let isLogging = false;
        let logData = [];
        let currentPower = 0;
        let currentCadence = 0;
        let currentHeartRate = 0;
        let speedBuffer = [];
        const SPEED_BUFFER_SIZE = 10; // 速度の平均化に使うサンプル数。大きいほど滑らかになるが反応は遅くなる


        let bleDevice = null;
        let ftmsCharacteristic = null;
        let hrDevice = null;
        let hrCharacteristic = null;
        const FTMS_SERVICE_UUID = 'fitness_machine';
        const INDOOR_BIKE_DATA_UUID = 'indoor_bike_data';

        const HR_SERVICE_UUID = 'heart_rate';
        const HR_MEASUREMENT_UUID = 'heart_rate_measurement';

        // 速度計算用の定数（適宜調整可能）
        const BASE_RESISTANCE = 15; // 平地での基本抵抗値
        const GRADIENT_FACTOR = 0.5; // 勾配による抵抗値の増加率
        const SCALING_FACTOR = 3;   // パワーから速度への換算係数
        const MAX_SPEED_KMH = 60;
        const MIN_SPEED_KMH = 1;

        const routeSettingsButton = document.getElementById('route-settings-button');
        const routeSettingsDropdown = document.getElementById('route-settings-dropdown');
        const routeButton = document.getElementById('route-button');
        const loadGpxButton = document.getElementById('load-gpx-button');
        const gpxFileInput = document.getElementById('gpx-file-input');
        const toggleTourButton = document.getElementById('toggle-tour-button');
        const bleConnectButton = document.getElementById('ble-connect-button');
        const hrConnectButton = document.getElementById('hr-connect-button');
        const logToggleButton = document.getElementById('log-toggle-button');
        const originInput = document.getElementById('origin-input');
        const destinationInput = document.getElementById('destination-input');
        const intervalInput = document.getElementById('interval-input');
        const speedInput = document.getElementById('speed-input');
        const travelModeButtons = document.querySelectorAll('.mode-switcher button');
        let currentTravelMode = 'DRIVING';

        const defaultSettings = {
            'DRIVING': { speed: 40, interval: 5 },
            'BICYCLING': { speed: 15, interval: 3 },
            'WALKING': { speed: 4, interval: 1 }
        };

        /**
         * UIの言語を設定します。
         * @param {string} lang - 言語コード ('ja' or 'en')
         */
        function setLanguage(lang) {
            if (!uiStrings[lang]) return;
            currentLang = lang;
            document.documentElement.lang = lang;

            // data-i18n属性を持つ静的なテキストを更新
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                if (uiStrings[lang][key]) {
                    el.textContent = uiStrings[lang][key];
                }
            });

            // data-i18n-placeholder属性を持つプレースホルダーを更新
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.dataset.i18nPlaceholder;
                if (uiStrings[lang][key]) {
                    el.placeholder = uiStrings[lang][key];
                }
            });

            // 状態によってテキストが変わるボタンを更新
            toggleTourButton.textContent = isTourRunning ? uiStrings[lang].stopTour : uiStrings[lang].startTour;
            bleConnectButton.textContent = (bleDevice && bleDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectPower;
            hrConnectButton.textContent = (hrDevice && hrDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectHr;
            logToggleButton.textContent = isLogging ? uiStrings[lang].stopLog : uiStrings[lang].startLog;

            // マーカーのタイトルを更新
            if (startMarker) startMarker.setTitle(uiStrings[lang].startPoint);
            if (endMarker) endMarker.setTitle(uiStrings[lang].endPoint);
            if (currentLocationMarker) currentLocationMarker.setTitle(uiStrings[lang].currentLocation);

            // 言語スイッチャーボタンのアクティブ状態を更新
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.lang === lang));
        }

        // ドロップダウンの表示/非表示を切り替える
        routeSettingsButton.addEventListener('click', (event) => {
            event.stopPropagation();
            routeSettingsDropdown.classList.toggle('show');
        });

        // ドロップダウン外をクリックしたら閉じる
        window.addEventListener('click', (event) => {
            if (!routeSettingsDropdown.contains(event.target) && !routeSettingsButton.contains(event.target)) {
                routeSettingsDropdown.classList.remove('show');
            }
        });

        /**
         * 巡回モードを設定し、UIを更新します。
         * @param {string} mode - ツアーモード ('DRIVING', 'BICYCLING', 'WALKING')
         */
        function setTravelMode(mode) {
            currentTravelMode = mode;
            travelModeButtons.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            intervalInput.value = defaultSettings[mode].interval;
        }

        travelModeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                setTravelMode(btn.dataset.mode);
            });
        });

        /**
         * マップ上のすべてのマーカーをクリアします。
         */
        function clearMarkers() {
            if (startMarker) startMarker.setMap(null);
            if (endMarker) endMarker.setMap(null);
            if (currentLocationMarker) currentLocationMarker.setMap(null);
            startMarker = null;
            endMarker = null;
            currentLocationMarker = null;
        }

        /**
         * ツアー状態を初期化します。
         */
        function resetTourState() {
            stopTour();
            clearMarkers();
            directionsRenderer.setDirections({ routes: [] });
            if (gpxRoutePolyline) {
                gpxRoutePolyline.setMap(null);
                gpxRoutePolyline = null;
            }
            routePoints = [];
            routeElevations = [];
            routeGradients = [];
            totalDistance = 0;
            distanceTraveled = 0;
            currentPointIndex = 0;
            speedInput.value = 0;
            document.getElementById('elevation').textContent = `N/A`;
            document.getElementById('gradient').textContent = `N/A`;
            updateInfoDisplay();
            toggleTourButton.disabled = true;

            // グラフをクリアして非表示にする
            const container = document.getElementById('elevation-chart-container');
            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            container.style.display = 'none';
        }

        /**
         * 経路データを処理し、マップとストリートビューを初期化します。
         * @param {google.maps.LatLng[]} path - 経路の座標の配列
         */
        async function processRoute(path) {
            routePoints = path;
            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noStreetView);
                return;
            }

            const firstPoint = routePoints[0];
            const lastPoint = routePoints[routePoints.length - 1];

            // 最初に全ポイントの累積距離を計算
            cumulativeDistances = [0];
            for (let i = 1; i < path.length; i++) {
                cumulativeDistances.push(cumulativeDistances[i-1] + getDistance(path[i-1], path[i]));
            }
            totalDistance = cumulativeDistances[cumulativeDistances.length - 1];

            try {
                // 1. 経路長に応じてサンプリング距離を動的に決定する
                const minSamplingDistance = 25; // 最小サンプリング距離 (m)
                const samplingDistance = (totalDistance >= 1000) ? (totalDistance * 0.025) : minSamplingDistance;

                sampledPointsData = [{ point: path[0], distance: 0 }];
                let distanceSinceLastSample = 0;
                for (let i = 1; i < path.length; i++) {
                    const dist = cumulativeDistances[i] - cumulativeDistances[i-1];
                    distanceSinceLastSample += dist;
                    if (distanceSinceLastSample >= samplingDistance) {
                        sampledPointsData.push({ point: path[i], distance: cumulativeDistances[i] });
                        distanceSinceLastSample = 0;
                    }
                }
                // 最後のポイントがサンプリングされていない場合、追加する
                if (sampledPointsData[sampledPointsData.length - 1].distance < totalDistance) {
                    sampledPointsData.push({ point: path[path.length - 1], distance: totalDistance });
                }

                // 2. サンプリングした点の標高を取得
                const sampledPoints = sampledPointsData.map(d => d.point);
                const sampleLimit = 512; // APIの上限
                let allElevationResults = [];

                for (let i = 0; i < sampledPoints.length; i += sampleLimit) {
                    const chunk = sampledPoints.slice(i, i + sampleLimit);
                    const { results: chunkResults } = await elevationService.getElevationForLocations({
                        locations: chunk,
                    });
                    if (!chunkResults || chunkResults.length !== chunk.length) {
                        const errorMessage = chunkResults ? `Expected ${chunk.length} results but got ${chunkResults.length}.` : 'No results from API.';
                        throw new Error(`Elevation fetch error in chunk [${i}-${i+chunk.length-1}]: ${errorMessage}`);
                    }
                    allElevationResults = allElevationResults.concat(chunkResults);
                }

                if (allElevationResults.length !== sampledPoints.length) {
                    throw new Error('Failed to get elevation for all sampled points.');
                }
                sampledPointsData.forEach((data, i) => {
                    data.elevation = allElevationResults[i].elevation;
                });

                // 標高の異常なスパイクを除去するためにメディアンフィルタを適用
                sampledPointsData = applyMedianFilter(sampledPointsData, 3);

                // 3. 元の経路の各点の標高を計算する
                routeElevations = new Array(path.length);

                // サンプリングされた点が2つ未満の場合（経路が非常に短い場合など）、
                // 全ポイントを最初の点の標高にするか、0で埋める
                if (sampledPointsData.length < 2) {
                    const singleElevation = sampledPointsData.length === 1 ? sampledPointsData[0].elevation : 0;
                    routeElevations.fill(singleElevation);
                } else {
                    // 線形補間で各点の標高を計算
                    let currentSegmentIndex = 0;
                    for (let i = 0; i < path.length; i++) {
                        const pointDistance = cumulativeDistances[i];
                        // 現在の点がどの補間セグメントに属するかを見つける
                        while (currentSegmentIndex < sampledPointsData.length - 2 && pointDistance > sampledPointsData[currentSegmentIndex + 1].distance) {
                            currentSegmentIndex++;
                        }
                        const startSample = sampledPointsData[currentSegmentIndex];
                        const endSample = sampledPointsData[currentSegmentIndex + 1];
                        const segmentDistance = endSample.distance - startSample.distance;
                        const distanceIntoSegment = pointDistance - startSample.distance;
                        const fraction = (segmentDistance > 0) ? distanceIntoSegment / segmentDistance : 0;
                        const interpolatedElevation = startSample.elevation + (endSample.elevation - startSample.elevation) * Math.max(0, Math.min(1, fraction));
                        routeElevations[i] = interpolatedElevation;
                    }
                }

                // 4. 元の経路の各点の勾配を計算する
                routeGradients = new Array(path.length);
                if (sampledPointsData.length >= 2) {
                    let currentSegmentIndex = 0;
                    let lastValidGradient = 0;
                    for (let i = 0; i < path.length; i++) {
                        const pointDistance = cumulativeDistances[i];
                        while (currentSegmentIndex < sampledPointsData.length - 2 && pointDistance > sampledPointsData[currentSegmentIndex + 1].distance) {
                            currentSegmentIndex++;
                        }
                        const startSample = sampledPointsData[currentSegmentIndex];
                        const endSample = sampledPointsData[currentSegmentIndex + 1];
                        const segmentDistance = endSample.distance - startSample.distance;
                        const elevationChange = endSample.elevation - startSample.elevation;

                        if (segmentDistance >= 1.0) { // 1m以上の場合のみ計算
                            lastValidGradient = (elevationChange / segmentDistance) * 100;
                        }
                        routeGradients[i] = lastValidGradient;
                    }
                } else {
                    routeGradients.fill(0);
                }
                showMessage(uiStrings[currentLang].elevationProcessed, false);
            } catch (error) {
                showMessage(uiStrings[currentLang].elevationError, true);
                console.error("Elevation processing error:", error);
                routeElevations = new Array(routePoints.length).fill(0);
            }

            startMarker = new google.maps.Marker({
                map: map,
                position: firstPoint,
                label: 'A',
                title: uiStrings[currentLang].startPoint,
            });
            endMarker = new google.maps.Marker({
                map: map,
                position: lastPoint,
                label: 'B',
                title: uiStrings[currentLang].endPoint,
            });
            currentLocationMarker = new google.maps.Marker({
                map: map,
                title: uiStrings[currentLang].currentLocation,
                icon: {
                    path: 'M -5,0 5,0 M 0,-5 0,5',
                    scale: 4,
                    strokeColor: '#e74c3c',
                    strokeWeight: 2,
                    fillColor: '#e74c3c',
                    fillOpacity: 1,
                },
                position: firstPoint,
                zIndex: 9999,
            });

            if (panorama) {
                panorama.setPosition(firstPoint);
                map.panTo(firstPoint);

                try {
                    if (routePoints.length > 1) {
                        const heading = getHeading(routePoints[0], routePoints[1]);
                        if (!isNaN(heading)) {
                            panorama.setPov({ heading: heading, pitch: 0, zoom: 1 });
                        }
                    }
                } catch (e) {
                    console.error("Error setting initial POV:", e);
                }
            }

            showMessage(uiStrings[currentLang].routeFound, false);
            updateInfoDisplay();
            toggleTourButton.disabled = false;

            // 初期グラフを描画
            drawElevationChart(0);
        }

        /**
         * ユーザー入力に基づいて経路を計算し表示します。
         */
        function calculateAndDisplayRoute() {
            resetTourState();

            const origin = originInput.value;
            const destination = destinationInput.value;
            const interpolationInterval = parseFloat(intervalInput.value);

            if (!origin || !destination) {
                showMessage(uiStrings[currentLang].originDestRequired);
                return;
            }
            if (isNaN(interpolationInterval) || interpolationInterval <= 0) {
                showMessage(uiStrings[currentLang].invalidInterval);
                return;
            }

            directionsService.route({
                origin: origin,
                destination: destination,
                travelMode: google.maps.TravelMode[currentTravelMode],
            }).then((response) => {
                if (response.status === 'OK') {
                    const overviewPath = response.routes[0].overview_path;
                    directionsRenderer.setDirections(response);

                    const interpolatedPath = [];
                    for (let i = 0; i < overviewPath.length - 1; i++) {
                        const p1 = overviewPath[i];
                        const p2 = overviewPath[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / interpolationInterval);
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                        }
                    }
                    interpolatedPath.push(overviewPath[overviewPath.length - 1]);

                    processRoute(interpolatedPath);
                } else {
                    throw new Error(`${uiStrings[currentLang].routeSearchFailed}${response.status}`);
                }
            }).catch((e) => {
                showMessage(uiStrings[currentLang].routeNotFound);
            });
        }

        loadGpxButton.addEventListener('click', () => {
            gpxFileInput.click();
        });

        gpxFileInput.addEventListener('change', (event) => {
            resetTourState();

            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxText = e.target.result;
                    const parser = new DOMParser();
                    const gpxDoc = parser.parseFromString(gpxText, 'application/xml');

                    const trkpts = gpxDoc.querySelectorAll('trkpt');
                    if (trkpts.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoTrackpoints);
                        return;
                    }

                    const gpxPoints = [];
                    trkpts.forEach(pt => {
                        const lat = parseFloat(pt.getAttribute('lat'));
                        const lon = parseFloat(pt.getAttribute('lon'));
                        if (!isNaN(lat) && !isNaN(lon)) {
                            gpxPoints.push(new google.maps.LatLng(lat, lon));
                        }
                    });

                    if (gpxPoints.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoCoordinates);
                        return;
                    }

                    const interpolationInterval = parseFloat(intervalInput.value);
                    const interpolatedPath = [];
                    for (let i = 0; i < gpxPoints.length - 1; i++) {
                        const p1 = gpxPoints[i];
                        const p2 = gpxPoints[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / interpolationInterval);
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                        }
                    }
                    interpolatedPath.push(gpxPoints[gpxPoints.length - 1]);

                    gpxRoutePolyline = new google.maps.Polyline({
                        path: interpolatedPath,
                        geodesic: true,
                        strokeColor: '#3498db',
                        strokeOpacity: 0.8,
                        strokeWeight: 5
                    });
                    gpxRoutePolyline.setMap(map);

                    processRoute(interpolatedPath);
                } catch (error) {
                    showMessage(uiStrings[currentLang].gpxParseError);
                }
            };
            reader.readAsText(file);
        });

        /**
         * ツアーの各ステップを実行する非同期関数。
         * 次の地点にストリートビューが存在するか確認し、存在する場合のみ表示を更新します。
         * 処理完了後、次のステップをsetTimeoutで予約します。
         */
        async function tourStep() {
            if (!isTourRunning) return;

            if (currentPointIndex >= routePoints.length - 1) {
                stopTour();
                showMessage(uiStrings[currentLang].destinationReached, false);
                return;
            }

            distanceTraveled += getDistance(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]);
            currentPointIndex++;

            const targetPosition = routePoints[currentPointIndex];

            try {
                const { data } = await streetViewService.getPanorama({
                    location: targetPosition,
                    radius: 100, // 検索半径を100mに設定
                    source: google.maps.StreetViewSource.DEFAULT, // 公式・ユーザー投稿の両方を対象
                    preference: google.maps.StreetViewPreference.NEAREST // 最も近い画像を優先
                });

                // パノラマが見つかった場合のみ、ストリートビューを更新
                if (data && data.location) {
                    const currentPanoId = panorama.getPano();
                    const newPanoId = data.location.pano;
                    const panoramaPosition = data.location.latLng;

                    // パノラマIDが変更された場合のみ、画像全体を読み込むsetPositionを実行
                    if (newPanoId && newPanoId !== currentPanoId) {
                        panorama.setPosition(panoramaPosition);
                    }

                    if (currentPointIndex + 1 < routePoints.length) {
                        // 進行方向は経路上の次のポイントを基準に計算
                        const heading = getHeading(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]);
                        if (!isNaN(heading)) {
                            // 視点(POV)の更新は毎回行う
                            panorama.setPov({ heading: heading, pitch: 0, zoom: 1 });
                        }
                    }
                } else {
                    // パノラマが見つからない場合は、黒い画面になるのを避けるため何もしない
                    console.log(`No panorama found near point ${currentPointIndex}. Skipping Street View update.`);
                }
            } catch (e) {
                // エラーコードとメッセージをコンソールに出力して原因を特定しやすくする
                console.error(`Error getting panorama data for point ${currentPointIndex}:`, e);
                if (e.code) console.error(`Street View API Error Code: ${e.code}`);
            }

            // 地図上のマーカーは常に経路上の座標に更新
            currentLocationMarker.setPosition(targetPosition);
            map.panTo(targetPosition);
            updateInfoDisplay();

            if (isLogging) {
                logData.push({
                    timestamp: new Date().toISOString(),
                    position: targetPosition,
                    power: currentPower,
                    cadence: currentCadence,
                    heartRate: currentHeartRate,
                    distance: distanceTraveled,
                    speed: currentTourSpeedKmH
                });
            }

            // 次のステップをスケジュール
            if (isTourRunning) {
                const speedKmH = parseFloat(speedInput.value) || 0;
                const intervalDistance = parseFloat(intervalInput.value);
                const speedMs = speedKmH * 1000 / 3600;

                let intervalTime = 1000; // 速度0の時のフォールバック
                if (speedMs > 0) {
                    intervalTime = (intervalDistance / speedMs) * 1000;
                }

                // 移動モードに応じてAPIリクエストの最小間隔を調整する。
                // ユーザー投稿データが多用されるサイクリングや徒歩モードでは、
                // パノラマの密度が高く、新しい画像の読み込みが頻繁に発生する可能性があるため、
                // 最小間隔を長めに設定し、タイムアウトのリスクを低減する。
                const minIntervalDriving = 600; // 自動車モード (ms)
                const minIntervalCyclingAndWalking = 1000; // 自転車・徒歩モード (ms)

                let minInterval;
                if (currentTravelMode === 'DRIVING') {
                    minInterval = minIntervalDriving;
                } else { // BICYCLING or WALKING
                    minInterval = minIntervalCyclingAndWalking;
                }
                tourTimerId = setTimeout(tourStep, Math.max(intervalTime, minInterval));
            }
        }

        function toggleTour() {
            if (isTourRunning) {
                stopTour();
            } else {
                startTour();
            }
        }

        function startTour() {
            if (isTourRunning) return;

            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noRouteForTour);
                return;
            }

            const speed = parseFloat(speedInput.value);
            const interval = parseFloat(intervalInput.value);

            if (isNaN(speed) || speed <= 0) {
                 showMessage(uiStrings[currentLang].invalidSpeed, true);
                 return;
            }
            if (isNaN(interval) || interval <= 0) {
                showMessage(uiStrings[currentLang].invalidInterval);
                return;
            }

            isTourRunning = true;
            toggleTourButton.textContent = uiStrings[currentLang].stopTour;
            tourStartTime = Date.now();

            map.setZoom(17);

            tourStep(); // ツアーループを開始
        }

        function stopTour() {
            if (tourTimerId) {
                clearTimeout(tourTimerId);
                tourTimerId = null;
            }
            isTourRunning = false;
            if (tourStartTime > 0) {
                totalTimeElapsed = totalTimeElapsed + (Date.now() - tourStartTime) / 1000;
                console.log(formatTime(Date.now()));
                console.log(formatTime(tourStartTime));
                console.log(formatTime(totalTimeElapsed));
                tourStartTime = 0;
            }
            toggleTourButton.textContent = uiStrings[currentLang].startTour;
        }

        async function connectToBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                disconnectFromBleDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingDevice, false);
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [FTMS_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingDevice, false);
                const server = await bleDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const ftmsService = await server.getPrimaryService(FTMS_SERVICE_UUID);
                ftmsCharacteristic = await ftmsService.getCharacteristic(INDOOR_BIKE_DATA_UUID);

                await ftmsCharacteristic.startNotifications();
                ftmsCharacteristic.addEventListener('characteristicvaluechanged', handleFTMSData);

                showMessage(uiStrings[currentLang].ftmsConnected, false);
                bleConnectButton.textContent = uiStrings[currentLang].disconnect;
                bleConnectButton.style.backgroundColor = '#e74c3c';

            } catch (error) {
                console.error(`${uiStrings[currentLang].btConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].btConnectionError}${error.message}`);
                bleConnectButton.textContent = uiStrings[currentLang].connectPower;
                bleConnectButton.style.backgroundColor = '#3498db';
                bleDevice = null;
                ftmsCharacteristic = null;
            }
        }

        function disconnectFromBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].deviceDisconnected, false);
            }
            if (ftmsCharacteristic) {
                ftmsCharacteristic.removeEventListener('characteristicvaluechanged', handleFTMSData);
                ftmsCharacteristic = null;
            }
            speedBuffer = []; // 速度バッファをリセット
            bleConnectButton.textContent = uiStrings[currentLang].connectPower;
            bleConnectButton.style.backgroundColor = '#3498db';
            document.getElementById('power-display').textContent = '0 W';
            document.getElementById('cadence-display').textContent = '0 rpm';
            stopTour(); // 切断時にツアーを停止
        }

        async function connectToHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                disconnectFromHrDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingHr, false);
                hrDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [HR_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingHr, false);
                const server = await hrDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const hrService = await server.getPrimaryService(HR_SERVICE_UUID);
                hrCharacteristic = await hrService.getCharacteristic(HR_MEASUREMENT_UUID);

                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);

                showMessage(uiStrings[currentLang].hrConnected, false);
                hrConnectButton.textContent = uiStrings[currentLang].disconnect;
                hrConnectButton.style.backgroundColor = '#e74c3c';

            } catch (error) {
                console.error(`${uiStrings[currentLang].hrConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].hrConnectionError}${error.message}`);
                hrConnectButton.textContent = uiStrings[currentLang].connectHr;
                hrConnectButton.style.backgroundColor = '#3498db';
                hrDevice = null;
                hrCharacteristic = null;
            }
        }

        function disconnectFromHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                hrDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].hrDisconnected, false);
            }
            if (hrCharacteristic) {
                hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                hrCharacteristic = null;
            }
            hrConnectButton.textContent = uiStrings[currentLang].connectHr;
            hrConnectButton.style.backgroundColor = '#3498db';
            document.getElementById('hr-display').textContent = '0 bpm';
        }

        /**
         * BLEから受信した心拍数データを処理します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            const rate16Bits = (flags & 0x1) !== 0;
            let heartRate;
            if (rate16Bits) {
                heartRate = value.getUint16(1, true); // Little endian
            } else {
                heartRate = value.getUint8(1);
            }
            currentHeartRate = heartRate;
            document.getElementById('hr-display').textContent = `${currentHeartRate} bpm`;
        }

        /**
         * ログ記録の開始/終了を切り替えます。
         */
        function toggleLogging() {
            isLogging = !isLogging;
            if (isLogging) {
                logData = []; // ログを初期化
                logToggleButton.textContent = uiStrings[currentLang].stopLog;
                logToggleButton.style.backgroundColor = '#f39c12'; // 記録中を示す色
                showMessage(uiStrings[currentLang].logStarted, false);
            } else {
                logToggleButton.textContent = uiStrings[currentLang].startLog;
                logToggleButton.style.backgroundColor = '#3498db';
                showMessage(uiStrings[currentLang].logStopped, false);
                if (logData.length > 1) { // データが2点以上ないとLapが作れない
                    if (confirm(uiStrings[currentLang].confirmSaveTcx)) {
                        saveLogAsTcx();
                    }
                }
            }
        }

        /**
         * 記録したログをTCXファイルとして保存します。
         */
        function saveLogAsTcx() {
            const startTime = logData.length > 0 ? logData[0].timestamp : new Date().toISOString();
            let maxSpeedMs = 0; // m/s単位での最大速度

            let trackpointsXml = logData.map(p => {
                let positionXml = '';
                if (p.position) {
                    positionXml = `
            <Position>
              <LatitudeDegrees>${p.position.lat()}</LatitudeDegrees>
              <LongitudeDegrees>${p.position.lng()}</LongitudeDegrees>
            </Position>`;
                }

                const speedMs = p.speed ? (p.speed * 1000 / 3600) : 0;
                if (speedMs > maxSpeedMs) {
                    maxSpeedMs = speedMs;
                }

                // Garmin拡張スキーマ(TPX)に速度を追加
                const tpxExtensions = `
              <TPX xmlns="http://www.garmin.com/xmlschemas/ActivityExtension/v2">
                <Watts>${p.power}</Watts>
                <Speed>${speedMs.toFixed(2)}</Speed>
              </TPX>`;

                return `
          <Trackpoint>
            <Time>${p.timestamp}</Time>${positionXml}
            <DistanceMeters>${p.distance.toFixed(2)}</DistanceMeters>
            <HeartRateBpm>
              <Value>${p.heartRate}</Value>
            </HeartRateBpm>
            <Cadence>${p.cadence}</Cadence>
            <Extensions>
              ${tpxExtensions}
            </Extensions>
          </Trackpoint>`;
            }).join('');

            const totalTimeSeconds = (new Date(logData[logData.length - 1].timestamp).getTime() - new Date(logData[0].timestamp).getTime()) / 1000;
            const totalDistanceMeters = logData.length > 0 ? logData[logData.length - 1].distance : 0;

            const tcxContent = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xsi:schemaLocation="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd" xmlns:ns5="http://www.garmin.com/xmlschemas/ActivityGoals/v1" xmlns:ns3="http://www.garmin.com/xmlschemas/ActivityExtension/v2" xmlns:ns2="http://www.garmin.com/xmlschemas/UserProfile/v2" xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ns4="http://www.garmin.com/xmlschemas/ProfileExtension/v1">
  <Activities>
    <Activity Sport="Biking">
      <Id>${startTime}</Id>
      <Lap StartTime="${startTime}">
        <TotalTimeSeconds>${totalTimeSeconds.toFixed(0)}</TotalTimeSeconds>
        <DistanceMeters>${totalDistanceMeters.toFixed(2)}</DistanceMeters>
        <MaximumSpeed>${maxSpeedMs.toFixed(2)}</MaximumSpeed>
        <Calories>0</Calories>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>${trackpointsXml}</Track>
      </Lap>
    </Activity>
  </Activities>
</TrainingCenterDatabase>`;

            const blob = new Blob([tcxContent], { type: 'application/vnd.garmin.tcx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const date = new Date(startTime);
            const filename = `activity_${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}.tcx`;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * BLEから受信したFTMSデータを処理します。
         * 速度を動的に計算し、UIを更新します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleFTMSData(event) {
            const value = event.target.value;
            const data = new DataView(value.buffer);
            const rawData = Array.from(new Uint8Array(data.buffer)).join(' ');

            const flags = data.getUint16(0, true);
            let offset = 2;

            if (flags & 0x01) {
            }
            if (flags & 0x02) {
                offset += 2;
            }
            if (flags & 0x04) {
                const instantaneousCadence = data.getUint16(offset, true) / 2;
                currentCadence = instantaneousCadence.toFixed(0);
                document.getElementById('cadence-display').textContent = `${currentCadence} rpm`;
                offset += 2;
            }
            if (flags & 0x08) {
                offset += 2;
            }
            if (flags & 0x10) {
                offset += 3;
            }
            if (flags & 0x20) {
                offset += 2;
            }
            if (flags & 0x40) {
                const power = data.getInt16(offset, true);
                currentPower = power;
                document.getElementById('power-display').textContent = `${currentPower} W`;

                // 動的な速度計算とツアー制御
                //if (isTourRunning) {
                        // 勾配とパワーを基に速度を計算
                        let resistance = BASE_RESISTANCE + (GRADIENT_FACTOR * currentGradient);
                        
                        // 抵抗が極端に小さくならないように下限値を設定し、速度の急なスパイクを防ぐ
                        const minResistance = 5; // 最小抵抗値（この値を大きくすると下り坂での速度が上がりにくくなる）
                        if (resistance < minResistance) {
                            resistance = minResistance;
                        }
                        let newSpeed = (power / resistance) * SCALING_FACTOR;
                        newSpeed = Math.max(MIN_SPEED_KMH, Math.min(newSpeed, MAX_SPEED_KMH));
                        
                        // --- 速度のスムージング処理 ---
                        // 計算された生の速度をバッファに追加
                        speedBuffer.push(newSpeed);
                        if (speedBuffer.length > SPEED_BUFFER_SIZE) {
                            speedBuffer.shift(); // 古いデータを削除
                        }
                        // バッファ内の速度の平均値を計算して滑らかにする
                        const smoothedSpeed = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
                        currentTourSpeedKmH = smoothedSpeed; // スムージングされた速度をグローバル変数に保存
                        
                        // 速度入力フィールドを更新し、巡回インターバルを再設定
                        speedInput.value = currentTourSpeedKmH.toFixed(1);
                        // ツアーループ内で速度が参照されるため、ここでのタイマー更新は不要
                    if (isTourRunning) {
                        if (power <= 0) {
                            stopTour();
                            showMessage(uiStrings[currentLang].powerZeroStop, true);
                        }
                    } else {
                        if (power > 0) {
                            startTour();
                            showMessage(uiStrings[currentLang].powerDetectedStart, true);
                        }
                    }
                //}
                offset += 2;
            }
            if (flags & 0x80) {
                offset += 2;
            }
        }

        function initMap() {
            const initialLocation = { lat: 35.681236, lng: 139.767125 };

            map = new google.maps.Map(document.getElementById('map'), {
                center: initialLocation,
                zoom: 12,
                streetViewControl: false,
            });

            panorama = new google.maps.StreetViewPanorama(document.getElementById('street-view'), {
                position: initialLocation,
                visible: true,
                pov: { heading: 0, pitch: 0, zoom: 1 }
            });

            map.setStreetView(panorama);

            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({ map: map, suppressMarkers: true });
            elevationService = new google.maps.ElevationService();
            streetViewService = new google.maps.StreetViewService();

            routeButton.addEventListener('click', calculateAndDisplayRoute);
            toggleTourButton.addEventListener('click', toggleTour);
            bleConnectButton.addEventListener('click', connectToBleDevice);
            logToggleButton.addEventListener('click', toggleLogging);
            hrConnectButton.addEventListener('click', connectToHrDevice);

            // 言語スイッチャーのイベントリスナー
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setLanguage(e.target.dataset.lang);
                });
            });

            // 手動での速度変更を検知
            speedInput.addEventListener('input', () => {
                const speed = parseFloat(speedInput.value);
                // 速度の変更はtourStepループ内で自動的に反映される
            });

            [originInput, destinationInput].forEach(input => {
                input.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        calculateAndDisplayRoute();
                    }
                });
            });

            const splitter = document.getElementById('splitter');
            const mapDiv = document.getElementById('map');
            const streetViewDiv = document.getElementById('street-view');
            const splitContainer = document.getElementById('split-container');
            let isDragging = false;
            let startPos;
            let startSize;

            streetViewDiv.style.flexGrow = '0';
            mapDiv.style.flexGrow = '0';

            const initialRatio = 0.7;
            const isMobile = window.innerWidth <= 767;
            if (isMobile) {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetHeight * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetHeight * (1 - initialRatio)}px`;
            } else {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetWidth * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetWidth * (1 - initialRatio)}px`;
            }

            splitter.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
                document.body.style.cursor = isMobile ? 'row-resize' : 'col-resize';
                mapDiv.style.transition = 'none';
                streetViewDiv.style.transition = 'none';
                if (isMobile) {
                    startPos = e.clientY;
                    startSize = streetViewDiv.offsetHeight;
                } else {
                    startPos = e.clientX;
                    startSize = streetViewDiv.offsetWidth;
                }
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging) return;
                isDragging = false;
                document.body.style.cursor = 'default';
                mapDiv.style.transition = 'flex 0.3s ease';
                streetViewDiv.style.transition = 'flex 0.3s ease';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = splitContainer.getBoundingClientRect();
                const minSize = 100;
                let newSize;
                if (isMobile) {
                    const delta = e.clientY - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.height - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.height - newSize}px`;
                } else {
                    const delta = e.clientX - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.width - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.width - newSize}px`;
                }
            });
        }

        function loadMapsScript() {
            if (window.google && window.google.maps) {
                initMap();
                return;
            }
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap&libraries=places,geometry`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadMapsScript();
            setLanguage(currentLang); // 初期言語を設定
        });
    </script>
</body>
</html>
