<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 100vw;
            overflow: hidden;
        }

        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            padding: 8px 15px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .dropdown-container {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: white;
            min-width: 300px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            padding: 10px;
            border-radius: 8px;
            flex-direction: column;
            gap: 10px;
        }

        #settings-dropdown {
            right: 0; /* 右端に表示 */
            left: auto;
            min-width: 250px; /* 経路設定と幅を合わせる */
        }

        .dropdown-content.show {
            display: flex;
        }

        /* マップ左下のコントロールコンテナ */
        #map-controls-container {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            margin: 10px;
        }
        #map-controls-container label {
            font-size: 13px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
        }

        /* トグルスイッチのスタイル */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3; /* 青色 */
        }
        input:checked + .slider:before {
            transform: translateX(14px);
        }

        .dropdown-content input[type="text"] {
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .dropdown-content button {
            width: 100%;
        }

        .input-group, .action-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-groups {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header-links {
            display: flex;
            align-items: center;
            gap: 15px;
            white-space: nowrap;
        }

        #speed-input, #interval-input {
            width: 60px;
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 15px;
            font-size: 0.9rem;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            white-space: nowrap;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #split-container {
            display: flex;
            flex-grow: 1;
            position: relative;
        }

        #map, #street-view {
            height: 100%;
            transition: flex 0.3s ease;
            position: relative;
        }

        #street-view {
            flex-grow: 0.7;
            flex-basis: 70%;
        }

        #map {
            flex-grow: 0.3;
            flex-basis: 30%;
        }

        .splitter {
            width: 8px;
            background-color: #bdc3c7;
            cursor: col-resize;
            z-index: 2;
        }

        #message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #e74c3c;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .mode-switcher {
            display: flex;
            border: 2px solid #3498db;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-switcher button {
            background-color: white;
            color: #3498db;
            padding: 8px 12px;
            border-radius: 0;
            box-shadow: none;
            transition: background-color 0.2s, color 0.2s;
        }

        .mode-switcher button.active {
            background-color: #3498db;
            color: white;
        }

        #info-display {
            background-color: #2c3e50;
            color: white;
            padding: 5px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px 15px; /* 横のgapを少し詰める */
            justify-content: flex-start; /* 左詰めにする */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1; /* 利用可能なスペースを均等に埋める */
        }
        .info-label {
            font-weight: bold;
            color: #bdc3c7;
        }
        .info-value {
            font-size: 1.1rem;
        }

        #lang-switcher {
            display: flex;
            gap: 5px;
        }
        .lang-btn {
            padding: 5px 10px;
            font-size: 0.8rem;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: none;
            transform: none;
        }
        .lang-btn:hover {
            background-color: #bdc3c7;
            transform: none;
        }
        .lang-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .header-links a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .header-links a:hover {
            text-decoration: underline;
        }
        #fullscreen-button {
            background-color: transparent;
            border: none;
            box-shadow: none;
            width: 40px;
            height: 40px;
            padding: 0px;
            cursor: pointer;
            color: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #fullscreen-button:hover {
            background-color: #ecf0f1;
            transform: none;
        }

        .infowindow-btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: none;
            transform: none;
        }
        .infowow-btn:hover {
            background-color: #2980b9;
        }

        #boost-button {
            display: none; /* Initially hidden */
            background-color: transparent;
            border: 1px solid #bdc3c7;
            color: #bdc3c7;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            box-shadow: none;
            transform: none;
            align-items: center;
            justify-content: center;
            transition: color 0.2s, background-color 0.2s, border-color 0.2s;
        }
        #boost-button.active {
            background-color: #f1c40f;
            color: white;
            border-color: #f1c40f;
        }

        #info-display #boost-button {
            display: none; /* Initially hidden */
            background-color: transparent;
            border: 1px solid #bdc3c7;
            color: #bdc3c7;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            box-shadow: none;
            transform: none;
            align-self: center; /* Vertically center in the flex container */
            margin: 0 10px;
            flex-grow: 0; /* この要素は伸縮させない */
        }
        #info-display #boost-button svg {
            width: 60%; /* ボタンの幅に対する割合でサイズを指定 */
            height: 100%;
        }
        #info-display #boost-button.active {
            background-color: #f1c40f;
            color: white;
            border-color: #f1c40f;
        }

        /* Google Places Autocomplete suggestions z-index fix */
        .pac-container {
            z-index: 2001; /* Must be higher than .modal-overlay's z-index */
        }


        /* Responsive design for mobile */
        @media (max-width: 767px) {
            .controls-area {
                padding: 10px;
                flex-direction: column;
                align-items: flex-start;
            }

            .input-group, .action-group {
                flex-direction: column;
                gap: 5px;
                width: 100%;
            }

            .input-group label {
                width: 100%;
                text-align: left;
            }

            #origin-input, #destination-input, #speed-input, #interval-input, button {
                width: 100%;
            }
            .dropdown-content {
                min-width: auto;
                width: 100%;
            }

            #split-container {
                flex-direction: column;
            }

            #street-view, #map {
                flex-basis: auto;
                height: 50%;
                width: 100%;
            }

            .splitter {
                height: 8px;
                width: 100%;
                cursor: row-resize;
            }
            .mode-switcher {
                width: 100%;
            }

            #info-display {
                gap: 10px;
                padding: 10px;
                justify-content: center;
            }
            .info-item {
                flex-basis: 45%;
                align-items: flex-start;
            }
        }

        #elevation-chart-container {
            width: 100%;
            height: 90px;
            background-color: #2c3e50;
            padding: 5px 20px;
            box-sizing: border-box;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none; /* Initially hidden */
        }
        
        #direction-settings-dropdown {
            padding: 5px;
        }
        #direction-switcher {
            border: none;
        }

        #elevation-chart {
            width: 100%;
            height: 100%;
            cursor: not-allowed; /* Initially not clickable */
        }

        /* ストリートビュー左下の表示方向コントロール（試作） */
        #direction-control-overlay {
            position: absolute;
            bottom: 10px;
            left: 50%;
            z-index: 5; /* ストリートビューのUIより手前に表示 */
            transform: translateX(-50%); /* 要素の幅の半分だけ左にずらして中央揃え */
            background-color: rgba(255, 255, 255, 0.85);
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 2px;
        }

        #direction-control-overlay button {
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
            box-shadow: none;
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        #direction-control-overlay button.active {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }

        /* オートブースト設定 */
        #auto-boost-settings {
            display: none; /* 初期状態では非表示 */
        }
        #auto-boost-settings-dropdown {
            min-width: 180px;
            padding: 15px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .settings-item label {
            white-space: nowrap;
        }
        .settings-item select {
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        .settings-item label {
            flex-grow: 1; /* ラベルが利用可能なスペースを埋める */
        }
        .settings-item select {
            flex-grow: 1; /* 残りのスペースをすべて使う */
        }
        .settings-item switch {
            width: 70px; /* 固定幅を指定 */
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        .settings-item input[type="number"] {
            width: 70px; /* 固定幅を指定 */
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        #settings-dropdown #lang-switcher {
            justify-content: center;
            margin-bottom: 10px;
        }
        #settings-dropdown input[type="number"], #settings-dropdown select {
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div class="controls-area">
            <div class="control-groups">
                <div class="dropdown-container">
                    <button id="route-settings-button" data-i18n="routeSettings">経路設定</button>
                    <div class="dropdown-content" id="route-settings-dropdown">                        
                        <input type="text" id="origin-input" placeholder="出発地: 例. 東京駅" data-i18n-placeholder="originPlaceholder">
                        <input type="text" id="destination-input" placeholder="目的地: 例. 渋谷スクランブル交差点" data-i18n-placeholder="destinationPlaceholder">
                        <div class="mode-switcher">
                            <button id="driving-mode-btn" data-mode="DRIVING" data-i18n="driving">自動車</button>
                            <button id="bicycling-mode-btn" data-mode="BICYCLING" class="active" data-i18n="bicycling">自転車</button>
                            <button id="walking-mode-btn" data-mode="WALKING" data-i18n="walking">徒歩</button>
                        </div>
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                            <label for="interval-input" data-i18n="interpolationInterval" style="white-space: nowrap;">補間間隔 (m):</label>
                            <input type="number" id="interval-input" value="3" min="1" max="100">
                        </div>
                        <button id="route-button" data-i18n="searchRoute">経路を検索</button>
                        <button id="load-gpx-button" data-i18n="loadGpx">GPXを読み込む</button>
                    </div>
                    <input type="file" id="gpx-file-input" accept=".gpx" style="display: none;">
                </div>
                <div class="action-group">
                    <label for="speed-input" data-i18n="speed">速度 (km/時):</label>
                    <input type="number" id="speed-input" value="0" min="1" max="60">
                    <button id="toggle-tour-button" disabled data-i18n="startTour">ツアー開始</button>
                    <button id="ble-connect-button" data-i18n="connectPower">パワーソースに接続</button>
                    <button id="hr-connect-button" data-i18n="connectHr">心拍計に接続</button>
                    <button id="log-toggle-button" data-i18n="startLog">ログ開始</button>
                </div>
            </div>
            <div class="header-links">
                <div class="dropdown-container" id="settings-container">
                    <button id="settings-button" title="設定" data-i18n="settings">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                            <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>
                        </svg>
                        <span data-i18n="settings">設定</span>
                    </button>
                    <div class="dropdown-content" id="settings-dropdown">
                        <div id="lang-switcher">
                            <button data-lang="ja" class="lang-btn active">日本語</button>
                            <button data-lang="en" class="lang-btn">English</button>
                        </div>
                        <div class="settings-item">
                            <label for="voice-guidance-toggle" data-i18n="voiceGuidance">音声ガイダンス</label>
                            <div>
                            <label class="switch">
                                <input type="checkbox" id="voice-guidance-toggle">
                                <span class="slider"></span>
                            </label>
                            </div>
                        </div>
                        <div class="settings-item">
                            <label for="voice-select" data-i18n="voiceSelect">声色</label>
                            <select id="voice-select" disabled></select>
                        </div>
                        <div class="settings-item">
                            <label for="geocode-interval-input" data-i18n="geocodeInterval">住所確認の間隔 (m)</label>
                            <input type="number" id="geocode-interval-input" min="100" max="5000" step="100">
                        </div>
                        <div class="settings-item">
                            <label for="auto-boost-threshold" data-i18n="autoBoostThresholdLabel">自動ブースト勾配 (%)</label>
                            <input type="number" id="auto-boost-threshold" min="0" max="50" step="1">
                        </div>
                    </div>
                </div>
                <button id="fullscreen-button" title="フルスクリーン">
                    <svg class="icon-fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="28" height="28">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    <svg class="icon-exit-fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="28" height="28" style="display: none;">
                        <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div id="info-display">
            <div class="info-item">
                <span class="info-label" data-i18n="totalDist">経路全体</span>
                <span class="info-value" id="total-dist">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="currentPos">現在位置</span>
                <span class="info-value" id="current-pos">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="distTraveled">移動距離</span>
                <span class="info-value" id="dist-traveled">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeElapsed">移動時間</span>
                <span class="info-value" id="time-elapsed">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeRemaining">残り時間</span>
                <span class="info-value" id="time-remaining">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="elevation">標高</span>
                <span class="info-value" id="elevation">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="gradient">勾配</span>
                <span class="info-value" id="gradient">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="power">パワー</span>
                <span class="info-value" id="power-display">0 W</span>
            </div>
            <button id="boost-button" title="ブースト">
                <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641z"/>
                </svg>
            </button>
            <div class="info-item">
                <span class="info-label" data-i18n="cadence">ケイデンス</span>
                <span class="info-value" id="cadence-display">0 rpm</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="heartRate">心拍数</span>
                <span class="info-value" id="hr-display">0 bpm</span>
            </div>
        </div>
        <div id="elevation-chart-container">
            <canvas id="elevation-chart"></canvas>
        </div>
        <div id="split-container">
            <div id="street-view">
                <!-- ストリートビュー左下の表示方向コントロール（試作） -->
                <div id="direction-control-overlay" class="mode-switcher">
                    <button data-angle="-90" data-i18n="left90">左90°</button>
                    <button data-angle="-45" data-i18n="left45">左45°</button>
                    <button data-angle="0" data-i18n="front" class="active">正面</button>
                    <button data-angle="45" data-i18n="right45">右45°</button>
                    <button data-angle="90" data-i18n="right90">右90°</button>
                </div>
            </div>
            <div class="splitter" id="splitter"></div>
            <div id="map"></div>
        </div>
        <!-- マップ左下に配置するコントロール -->
        <div id="map-controls-container" style="display: none;">
            <label for="sv-coverage-toggle" data-i18n="svCoverage">SV道路表示</label>
            <label class="switch">
                <input type="checkbox" id="sv-coverage-toggle">
                <span class="slider"></span>
            </label>
            <label for="user-content-toggle" data-i18n="userContent">ユーザー投稿</label>
            <label class="switch">
                <input type="checkbox" id="user-content-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
    </div>
    <div id="message-box"></div>

    <script>

        const uiStrings = {
            ja: {
                routeSettings: '経路設定',
                originPlaceholder: '出発地: 例. 東京駅',
                destinationPlaceholder: '目的地: 例. 渋谷スクランブル交差点',
                driving: '自動車',                
                bicycling: '自転車',
                walking: '徒歩',
                interpolationInterval: '補間間隔 (m):',
                searchRoute: '経路を検索',
                loadGpx: 'GPXを読み込む',
                speed: '速度 (km/時):',
                userContent: 'ユーザー投稿',
                startTour: 'ツアー開始',
                stopTour: 'ツアー停止',
                connectPower: 'パワーソースに接続',
                connectHr: '心拍計に接続',
                disconnect: '接続解除',
                startLog: 'ログ開始',
                stopLog: 'ログ終了',
                distTraveled: '移動距離',
                totalDist: '経路全体',
                currentPos: '現在位置',
                timeElapsed: '移動時間',
                timeRemaining: '残り時間',
                elevation: '標高',
                gradient: '勾配',
                power: 'パワー',
                cadence: 'ケイデンス',
                heartRate: '心拍数',
                directionSettings: '表示方向',
                left90: '左90°',
                left45: '左45°',
                front: '正面',
                right45: '右45°',
                right90: '右90°',
                startPoint: '出発地',
                endPoint: '目的地',
                currentLocation: '現在地',
                // messages
                noStreetView: 'この経路のストリートビューデータが見つかりませんでした。',
                routeFound: '経路が見つかりました！巡回を開始できます。',
                elevationProcessed: '経路の標高データを補正しました。',
                elevationError: '標高データの取得または補正に失敗しました。',
                originDestRequired: '出発地と目的地を入力してください。',
                invalidInterval: '有効な補間間隔を入力してください。',
                routeSearchFailed: '経路検索に失敗しました: ',
                routeNotFound: '経路が見つかりませんでした。場所を確認してください。',
                gpxNoTrackpoints: 'GPXファイルにトラックポイントが見つかりませんでした。',
                gpxNoCoordinates: 'GPXファイルから有効な座標を抽出できませんでした。',
                gpxParseError: 'GPXファイルの解析中にエラーが発生しました。',
                destinationReached: '目的地に到達しました。',
                noRouteForTour: 'まず経路を検索するかGPXファイルを読み込んでください。',
                invalidSpeed: '有効な速度を入力してください。',
                searchingDevice: 'デバイスを検索中です...',
                connectingDevice: 'デバイスに接続中です...',
                gattConnected: 'GATTサーバーに接続しました。',
                ftmsConnected: 'FTMSデバイスに接続しました。',
                btConnectionFailed: 'Bluetooth接続に失敗しました:',
                btConnectionError: 'Bluetooth接続エラー: ',
                deviceDisconnected: 'デバイスから切断しました。',
                searchingHr: '心拍計を検索中です...',
                connectingHr: '心拍計に接続中です...',
                hrConnected: '心拍計に接続しました。',
                hrConnectionFailed: '心拍計の接続に失敗しました:',
                hrConnectionError: '心拍計接続エラー: ',
                hrDisconnected: '心拍計から切断しました。',
                logStarted: 'ログ記録を開始しました。',
                logStopped: 'ログ記録を終了しました。',
                confirmSaveTcx: '記録したアクティビティをTCXファイルとして保存しますか？',
                powerZeroStop: '速度が低下したためツアーを停止しました。',
                powerDetectedStart: 'パワーを検出。ツアーを開始します。',
                jumpDisabledDuringTour: 'ツアー中はジャンプできません。',
                fullscreen: 'フルスクリーン',
                exitFullscreen: 'フルスクリーン解除',
                fullscreenError: 'フルスクリーンモードへの移行に失敗しました: ',
                setAsOrigin: 'ここへ移動',
                setAsDestinationAndSearch: 'ここへの経路を検索',
                setAsDestination: '目的地に設定',
                setAsHome: 'ホームに設定',
                arrivedAt: '{location} に到着しました。おつかれさまでした。',
                homeSet: 'ホーム地点を設定しました。次回起動時にこの場所から開始します。',
                boost: 'ブースト',
                municipalityGuidance: '{municipality} を移動中です。',
                settings: '設定',
                voiceGuidance: '地名アナウンス',
                departingFrom: '{location} から出発します。',
                voiceSelect: '声色',
                geocodeInterval: '地名確認の間隔 (m)',
                autoBoostSettings: '自動ブースト',
                autoBoostThresholdLabel: '自動ブースト勾配 (%)',
                boostOn: 'ブーストON',
                routeSettingsDisabled: 'ツアー中またはログ記録中は経路設定を変更できません。',
                searchForPlace: '場所を検索',
                svCoverage: 'SV道路表示'
            },
            en: {
                routeSettings: 'Route Settings',
                originPlaceholder: 'Origin: e.g., Tokyo Station',
                destinationPlaceholder: 'Destination: e.g., Shibuya Crossing',
                driving: 'Driving',
                bicycling: 'Bicycling',
                walking: 'Walking',
                interpolationInterval: 'Interval (m):',
                searchRoute: 'Search Route',
                loadGpx: 'Load GPX',
                userContent: 'User Content',
                speed: 'Speed (km/h):',
                startTour: 'Start Tour',
                stopTour: 'Stop Tour',
                connectPower: 'Connect P.S.',
                connectHr: 'Connect H.R.',
                disconnect: 'Disconnect',
                startLog: 'Start Logging',
                stopLog: 'Stop Logging',
                distTraveled: 'Distance Traveled',
                totalDist: 'Total Distance',
                currentPos: 'Current Position',
                timeElapsed: 'Time Elapsed',
                timeRemaining: 'Time Remaining',
                elevation: 'Elevation',
                gradient: 'Gradient',
                power: 'Power',
                cadence: 'Cadence',
                heartRate: 'Heart Rate',
                directionSettings: 'View Dir',
                left90: 'Left 90°',
                left45: 'Left 45°',
                front: 'Front',
                right45: 'Right 45°',
                right90: 'Right 90°',
                startPoint: 'Start Point',
                endPoint: 'End Point',
                currentLocation: 'Current Location',
                // messages
                noStreetView: 'Street View data could not be found for this route.',
                routeFound: 'Route found! You can start the tour.',
                elevationProcessed: 'Route elevation data has been processed.',
                elevationError: 'Failed to get or process elevation data.',
                originDestRequired: 'Please enter an origin and destination.',
                invalidInterval: 'Please enter a valid interpolation interval.',
                routeSearchFailed: 'Directions request failed due to: ',
                routeNotFound: 'Route not found. Please check the locations.',
                gpxNoTrackpoints: 'No trackpoints found in the GPX file.',
                gpxNoCoordinates: 'Could not extract valid coordinates from the GPX file.',
                gpxParseError: 'An error occurred while parsing the GPX file.',
                destinationReached: 'You have reached your destination.',
                noRouteForTour: 'Please search for a route or load a GPX file first.',
                invalidSpeed: 'Please enter a valid speed.',
                searchingDevice: 'Searching for device...',
                connectingDevice: 'Connecting to device...',
                gattConnected: 'Connected to GATT Server.',
                ftmsConnected: 'Connected to FTMS device.',
                btConnectionFailed: 'Bluetooth connection failed:',
                btConnectionError: 'Bluetooth connection error: ',
                deviceDisconnected: 'Disconnected from device.',
                searchingHr: 'Searching for heart rate monitor...',
                connectingHr: 'Connecting to heart rate monitor...',
                hrConnected: 'Connected to heart rate monitor.',
                hrConnectionFailed: 'Failed to connect to heart rate monitor:',
                hrConnectionError: 'Heart rate monitor connection error: ',
                hrDisconnected: 'Disconnected from heart rate monitor.',
                logStarted: 'Log recording started.',
                logStopped: 'Log recording stopped.',
                confirmSaveTcx: 'Do you want to save the recorded activity as a TCX file?',
                powerZeroStop: 'Tour stopped due to low speed.',
                powerDetectedStart: 'Power detected. Starting the tour.',
                jumpDisabledDuringTour: 'Cannot jump during an active tour.',
                fullscreen: 'Fullscreen',
                exitFullscreen: 'Jump Here',
                fullscreenError: 'Error attempting to enable full-screen mode: ',
                setAsOrigin: 'Set as Origin',
                setAsDestinationAndSearch: 'Route to here',
                setAsDestination: 'Set as Destination',
                setAsHome: 'Set as Home',
                arrivedAt: 'Arrived at {location}. Well done!',
                homeSet: 'Home location set. The app will start here next time.',
                boost: 'Boost',
                municipalityGuidance: 'Now passing through {municipality}.',
                settings: 'Settings',
                voiceGuidance: 'Location Announcement',
                departingFrom: 'Departing from {location}.',
                voiceSelect: 'Voice',
                geocodeInterval: 'Location Check Interval (m)',
                autoBoostSettings: 'Auto Boost',
                autoBoostThresholdLabel: 'Auto Boost Gradient',
                boostOn: 'Boost ON',
                routeSettingsDisabled: 'Cannot change route settings during a tour or while logging.',
                searchForPlace: 'Search for a Place',
                svCoverage: 'SV Coverage',
            }
        };
        let currentLang = 'ja';

        /**
         * メッセージボックスにメッセージを表示します。
         * @param {string} message - 表示するメッセージ
         * @param {boolean} isError - エラーメッセージかどうか
         */
        function showMessage(message, isError = true) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.style.backgroundColor = isError ? '#e74c3c' : '#27ae60';
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.opacity = '1';
            }, 10);
            setTimeout(() => {
                messageBox.style.opacity = '0';
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 500);
            }, 3000);
        }

        /**
         * グラフの横軸に最適な目盛り間隔を計算します。
         * @param {number} totalDistance - 経路の総距離 (m)
         * @returns {number} - 目盛り間隔 (m)
         */
        function getNiceTickInterval(totalDistance) {
            if (totalDistance <= 0) return 500; // デフォルト値

            const targetTicks = 8; // 目指す目盛りの数
            const rawInterval = totalDistance / targetTicks;
            const power = Math.pow(10, Math.floor(Math.log10(rawInterval)));
            const normalizedInterval = rawInterval / power;

            if (normalizedInterval < 1.5) {
                return Math.max(1 * power, 10);
            } else if (normalizedInterval < 3) {
                return Math.max(2 * power, 10);
            } else if (normalizedInterval < 7) {
                return Math.max(5 * power, 10);
            }
            return Math.max(10 * power, 10);
        }

        /**
         * 経路全体の標高グラフを描画します。
         * @param {number} currentDistance - 現在の移動距離 (m)
         */
        function drawElevationChart(currentDistance = 0) {
            // グラフ描画に必要なデータが揃っているか確認
            const container = document.getElementById('elevation-chart-container');
            if (routeElevations.length < 2 || routeGradients.length < 2) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';

            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');

            // 高DPIディスプレイに対応
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            ctx.clearRect(0, 0, width, height);

            // 標高データの範囲を計算
            const minElev = Math.min(...routeElevations);
            const maxElev = Math.max(...routeElevations);
            const elevRange = maxElev - minElev;

            // 勾配データの範囲を計算（0%を中心に上下対称にすると見やすい）
            const minGrad = Math.min(...routeGradients);
            const maxGrad = Math.max(...routeGradients);
            const absMaxGrad = Math.max(Math.abs(minGrad), Math.abs(maxGrad), 2); // 最小でも±2%の範囲を確保
            const gradRange = absMaxGrad * 2;

            const padding = { top: 10, bottom: 20, left: 40, right: 40 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // 座標計算用のヘルパー関数
            const getX = (dist) => padding.left + (dist / totalDistance) * chartWidth;
            const getElevY = (elev) => padding.top + chartHeight - ((elev - minElev) / (elevRange || 1)) * chartHeight;
            const getGradY = (grad) => padding.top + chartHeight - ((grad - (-absMaxGrad)) / (gradRange || 1)) * chartHeight;

            // --- グラフの描画 ---

            // 1. 勾配グラフの0%基準線
            ctx.beginPath();
            const zeroY = getGradY(0);
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(width - padding.right, zeroY);
            ctx.strokeStyle = 'rgba(243, 156, 18, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. 標高グラフ（エリア）
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(52, 152, 219, 0.3)');
            gradient.addColorStop(1, 'rgba(44, 62, 80, 0.1)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.lineTo(getX(totalDistance), height - padding.bottom);
            ctx.lineTo(getX(0), height - padding.bottom);
            ctx.closePath();
            ctx.fill();

            // 3. 勾配グラフ（線）
            ctx.beginPath();
            ctx.moveTo(getX(0), getGradY(routeGradients[0]));
            for (let i = 1; i < routeGradients.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getGradY(routeGradients[i]));
            }
            ctx.strokeStyle = 'rgba(243, 156, 18, 0.8)'; // オレンジ色
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // 4. 標高グラフ（線）
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 5. 横軸の目盛りとラベルを描画
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(189, 195, 199, 0.2)'; // #bdc3c7 with alpha
            ctx.lineWidth = 1;
            ctx.font = '9px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#bdc3c7';

            const tickInterval = getNiceTickInterval(totalDistance);
            for (let dist = tickInterval; dist < totalDistance; dist += tickInterval) {
                const x = getX(dist);
                ctx.moveTo(x, height - padding.bottom);
                ctx.lineTo(x, height - padding.bottom + 4); // 4pxの短い線

                const distKm = (dist / 1000);
                const precision = Math.max(0, -Math.floor(Math.log10(tickInterval / 1000)));
                const label = distKm.toFixed(precision);
                ctx.fillText(label, x, height - padding.bottom + 15);
            }
            ctx.stroke();

            // 6. 軸ラベルの描画
            ctx.fillStyle = '#bdc3c7';
            ctx.font = '10px Inter';
            // 左側：標高
            ctx.textAlign = 'right';
            ctx.fillText(`${maxElev.toFixed(0)} m`, padding.left - 5, padding.top + 5);
            ctx.fillText(`${minElev.toFixed(0)} m`, padding.left - 5, height - padding.bottom);
            // 右側：勾配
            ctx.fillStyle = 'rgba(243, 156, 18, 0.9)';
            ctx.textAlign = 'left';
            ctx.fillText(`${absMaxGrad.toFixed(1)} %`, width - padding.right + 5, getGradY(absMaxGrad) + 3);
            ctx.fillText(`${(-absMaxGrad).toFixed(1)} %`, width - padding.right + 5, getGradY(-absMaxGrad) + 3);

            // 7. 現在地マーカー
            if (currentDistance > 0 && currentDistance < totalDistance) {
                const markerX = getX(currentDistance);
                const markerY = getElevY(routeElevations[currentPointIndex]);
                ctx.beginPath();
                ctx.moveTo(markerX, padding.top);
                ctx.lineTo(markerX, height - padding.bottom);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(markerX, markerY, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        /**
         * 標高データのスパイク（異常値）を除去するためにメディアンフィルタを適用します。
         * これにより、APIから返される稀な外れ値が勾配計算に与える影響を抑制します。
         * @param {Array<Object>} pointsData - 'elevation'プロパティを持つオブジェクトの配列
         * @param {number} windowSize - フィルタのウィンドウサイズ（3以上の奇数を推奨）
         * @returns {Array<Object>} - フィルタリングされた標高データを持つ新しい配列
         */
        function applyMedianFilter(pointsData, windowSize) {
            if (windowSize % 2 === 0 || windowSize < 3 || pointsData.length < windowSize) {
                return pointsData; // フィルタを適用できない場合は元のデータを返す
            }
            const filteredPoints = [];
            const halfWindow = Math.floor(windowSize / 2);

            for (let i = 0; i < pointsData.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(pointsData.length - 1, i + halfWindow);
                const windowSlice = pointsData.slice(start, end + 1);
                const elevations = windowSlice.map(p => p.elevation).sort((a, b) => a - b);
                const medianElevation = elevations[Math.floor(elevations.length / 2)];
                filteredPoints.push({ ...pointsData[i], elevation: medianElevation });
            }
            return filteredPoints;
        }

        /**
         * 2つの緯度/経度座標間の距離をメートル単位で計算します。
         * @param {google.maps.LatLng} p1 - 最初の座標
         * @param {google.maps.LatLng} p2 - 2番目の座標
         * @returns {number} - 2点間の距離（メートル）
         */
        function getDistance(p1, p2) {
            const R = 6371e3;
            const φ1 = p1.lat() * Math.PI / 180;
            const φ2 = p2.lat() * Math.PI / 180;
            const Δφ = (p2.lat() - p1.lat()) * Math.PI / 180;
            const Δλ = (p2.lng() - p1.lng()) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        /**
         * 2点間で補間された緯度/経度座標を計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @param {number} fraction - 補間率 (0-1)
         * @returns {google.maps.LatLng} - 補間された座標
         */
        function interpolate(from, to, fraction) {
            const lat = from.lat() + (to.lat() - from.lat()) * fraction;
            const lng = from.lng() + (to.lng() - from.lng()) * fraction;
            return new google.maps.LatLng(lat, lng);
        }

        /**
         * 2点間の進行方向（ヘディング）を度単位で計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @returns {number} - 進行方向（度）
         */
        function getHeading(from, to) {
            if (from.lat() === to.lat() && from.lng() === to.lng()) {
                return 0;
            }

            const lat1 = from.lat() * Math.PI / 180;
            const lon1 = from.lng() * Math.PI / 180;
            const lat2 = to.lat() * Math.PI / 180;
            const lon2 = to.lng() * Math.PI / 180;

            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let heading = Math.atan2(y, x) * 180 / Math.PI;

            heading = (heading + 360) % 360;
            return heading;
        }

        /**
         * 秒数を hh:mm:ss 形式にフォーマットします。
         * @param {number} seconds - 秒数
         * @returns {string} - フォーマットされた時間文字列
         */
        function formatTime(seconds) {
            const h = Math.floor(Math.abs(seconds) / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        /**
         * UI上の情報を更新します。
         */
        function updateInfoDisplay() {
            const totalDistanceKm = (totalDistance / 1000).toFixed(2);
            const currentPositionKm = (currentPositionDistance / 1000).toFixed(2);
            const distanceTraveledKm = (distanceTraveled / 1000).toFixed(2);
            const timeElapsed = totalTimeElapsed + (tourStartTime > 0 ? (Date.now() - tourStartTime) / 1000 : 0);

            const remainingDistance = Math.max(0, totalDistance - currentPositionDistance);            const speedKmH = currentSpeedMps * 3.6;
            let timeRemaining = 0;
            if (speedKmH > 0) {
                timeRemaining = (remainingDistance / 1000) / speedKmH * 3600;
            }

            document.getElementById('current-pos').textContent = `${currentPositionKm} km`;
            document.getElementById('total-dist').textContent = `${totalDistanceKm} km`;
            document.getElementById('dist-traveled').textContent = `${distanceTraveledKm} km`;
            document.getElementById('time-elapsed').textContent = formatTime(timeElapsed);
            document.getElementById('time-remaining').textContent = formatTime(timeRemaining);

            if (routeElevations.length > 0 && currentPointIndex < routeElevations.length && cumulativeDistances.length > currentPointIndex) {
                const currentElevation = routeElevations[currentPointIndex];
                document.getElementById('elevation').textContent = `${currentElevation.toFixed(1)} m`;

                // 現在地が属するサンプリング区間の勾配を計算する
                if (sampledPointsData.length >= 2) {
                    const currentDistance = cumulativeDistances[currentPointIndex];

                    // 現在地がどのサンプリング区間にいるかを探す
                    let segmentIndex = 0;
                    while (segmentIndex < sampledPointsData.length - 2 && currentDistance >= sampledPointsData[segmentIndex + 1].distance) {
                        segmentIndex++;
                    }

                    const startSample = sampledPointsData[segmentIndex];
                    const endSample = sampledPointsData[segmentIndex + 1];

                    const segmentDistance = endSample.distance - startSample.distance;
                    const elevationChange = endSample.elevation - startSample.elevation;

                    // 勾配計算の安定化：走行中の区間が計算に十分な長さを持つ場合のみ、勾配を更新する。
                    // 短い区間では、直前の有効な勾配の値を維持することで、異常なスパイクを防ぐ。
                    const MIN_GRADIENT_DISTANCE = 1.0; // 勾配計算に使用する最小距離(m)

                    if (segmentDistance >= MIN_GRADIENT_DISTANCE) {
                        currentGradient = (elevationChange / segmentDistance) * 100;
                    }
                } else {
                    currentGradient = 0; // サンプリングデータが不十分な場合
                }
                document.getElementById('gradient').textContent = `${currentGradient.toFixed(1)} %`;

                // 勾配の値に応じて色を変更
                const gradientValueEl = document.getElementById('gradient');
                if (currentGradient >= 10) {
                    gradientValueEl.style.color = '#e74c3c'; // 赤
                } else if (currentGradient >= 5) {
                    gradientValueEl.style.color = '#f1c40f'; // 黄
                } else {
                    gradientValueEl.style.color = ''; // デフォルトに戻す
                }
            } else {
                 document.getElementById('elevation').textContent = `N/A`;
                 document.getElementById('gradient').textContent = `N/A`;
                 currentGradient = 0;
            }

            // グラフを更新
            drawElevationChart(currentPositionDistance);
        }

        let map, panorama;
        let directionsService, directionsRenderer, elevationService, streetViewService, streetViewCoverageLayer;
        let routePoints = [];
        let routeGradients = [];
        let routeElevations = [];
        let gpxRoutePolyline = null;
        let cumulativeDistances = [];
        let sampledPointsData = [];
        let physicsIntervalId = null;
        let lastPhysicsUpdateTime = 0;
        let distanceSinceLastSvUpdate = 0;
        const STREETVIEW_UPDATE_DISTANCE = 20; // 20mごとにストリートビューを更新
        const PHYSICS_INTERVAL_MS = 500; // 500ms (2Hz)
        let currentLocationMarker;
        let isTourRunning = false;
        let currentPointIndex = 0;
        let startMarker, endMarker;
        let totalDistance = 0;
        let wakeLockSentinel = null;
        let currentPositionDistance = 0; // 経路上の現在位置を示す距離
        let distanceTraveled = 0; // 実際に走行した総距離
        let tourStartTime = 0;
        let directionOffset = 0;
        let totalTimeElapsed = 0;
        let currentGradient = 0;
        let currentTourSpeedKmH = 0;
        let isLogging = false;
        let logData = [];
        let logStartDistance = 0; // ログ開始時の走行距離
        let logStartTime = 0; // ログ開始時刻
        let currentPower = 0;
        let showUserContent = true; // ユーザー投稿データを表示するかのフラグ
        let currentCadence = 0;
        let currentHeartRate = 0;
        let isBoostActive = false;
        const BOOST_FACTOR = 1.5;
        let autoBoostThreshold = 10; // オートブーストのしきい値（%）
        let currentSpeedMps = 0; // 現在の速度 (m/s)

        let placesService, infoWindow, selectedPlace = null;
        let geocoder;
        let originLatLng = null, destinationLatLng = null;

        // 場所検索モーダル用
        // 出発地・目的地のオートコンプリート用
        let originAutocomplete, destinationAutocomplete;


        let currentMunicipality = ''; // 現在の市区町村名を保持
        let distanceSinceLastGeocode = 0; // 最後のジオコードからの距離
        let geocodeIntervalDistance = 1000; // 住所確認の間隔 (m)
        const PHYSICS_CONSTANTS = {
            RIDER_MASS: 70, // kg
            BIKE_MASS: 10, // kg
            get TOTAL_MASS() { return this.RIDER_MASS + this.BIKE_MASS; },
            CRR: 0.005, // 転がり抵抗係数 (asphalt)
            CDA: 0.3,   // 空気抵抗係数 * 前面投影面積 (m^2)
            RHO: 1.225, // 空気密度 (kg/m^3)
            G: 9.81,    // 重力加速度 (m/s^2)
            DRIVETRAIN_EFFICIENCY: 0.95, // 駆動系の効率
            MIN_SPEED_FOR_FORCE_CALC_MPS: 1.0, // 推進力計算時の最低速度 (m/s)
            STOPPING_SPEED_KMH: 3 // ツアーが自動停止する速度 (km/h)
        };

        let bleDevice = null;
        let ftmsCharacteristic = null;
        let hrDevice = null;
        let hrCharacteristic = null;
        const FTMS_SERVICE_UUID = 'fitness_machine';
        const INDOOR_BIKE_DATA_UUID = 'indoor_bike_data';

        const HR_SERVICE_UUID = 'heart_rate';
        const HR_MEASUREMENT_UUID = 'heart_rate_measurement';

        const routeSettingsButton = document.getElementById('route-settings-button');
        const routeSettingsDropdown = document.getElementById('route-settings-dropdown');
        const routeButton = document.getElementById('route-button');
        const loadGpxButton = document.getElementById('load-gpx-button');
        const gpxFileInput = document.getElementById('gpx-file-input');
        const toggleTourButton = document.getElementById('toggle-tour-button');
        const bleConnectButton = document.getElementById('ble-connect-button');
        const hrConnectButton = document.getElementById('hr-connect-button');
        const logToggleButton = document.getElementById('log-toggle-button');
        const boostButton = document.getElementById('boost-button');
        const settingsContainer = document.getElementById('settings-container');
        const settingsButton = document.getElementById('settings-button');
        const settingsDropdown = document.getElementById('settings-dropdown');
        const voiceGuidanceToggle = document.getElementById('voice-guidance-toggle');
        const voiceSelect = document.getElementById('voice-select');
        const geocodeIntervalInput = document.getElementById('geocode-interval-input');
        const autoBoostThresholdInput = document.getElementById('auto-boost-threshold');
        const originInput = document.getElementById('origin-input');
        const destinationInput = document.getElementById('destination-input');
        const intervalInput = document.getElementById('interval-input');
        // 新しいオーバーレイのボタンのみを取得
        const directionButtons = document.querySelectorAll('#direction-control-overlay button');
        const speedInput = document.getElementById('speed-input');
        const travelModeButtons = document.querySelectorAll('.mode-switcher button');
        let fullscreenButton;        let currentTravelMode = 'BICYCLING';

        const defaultSettings = {
            'DRIVING': { speed: 40, interval: 5 },
            'BICYCLING': { speed: 15, interval: 3 },
            'WALKING': { speed: 4, interval: 1 }
        };

        /**
         * フルスクリーンモードを切り替えます。
         */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    showMessage(`${uiStrings[currentLang].fullscreenError}${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        /**
         * フルスクリーンボタンのテキストを現在の状態に合わせて更新します。
         */
        function updateFullscreenButtonState() {
            if (!fullscreenButton) return;
            const iconFullscreen = fullscreenButton.querySelector('.icon-fullscreen');
            const iconExitFullscreen = fullscreenButton.querySelector('.icon-exit-fullscreen');

            if (document.fullscreenElement) {
                iconFullscreen.style.display = 'none';
                iconExitFullscreen.style.display = 'block';
                fullscreenButton.title = uiStrings[currentLang].exitFullscreen;
            } else {
                iconFullscreen.style.display = 'block';
                iconExitFullscreen.style.display = 'none';
                fullscreenButton.title = uiStrings[currentLang].fullscreen;
            }
        }

        // --- 音声合成関連 ---
        let voices = [];
        let isVoiceGuidanceEnabled = true;

        function populateVoiceList() {
            if (typeof speechSynthesis === 'undefined') return;
            voices = speechSynthesis.getVoices().filter(voice => voice.lang.startsWith(currentLang));
            voiceSelect.innerHTML = '';
            if (voices.length > 0) {
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute('data-name', voice.name);
                    voiceSelect.appendChild(option);
                });
                voiceSelect.disabled = false;
                // 保存された音声を選択 (言語が変わっても対応できるように)
                const savedVoiceName = localStorage.getItem('selectedVoiceName');
                if (savedVoiceName) {
                    const savedOption = Array.from(voiceSelect.options).find(opt => opt.getAttribute('data-name') === savedVoiceName);
                    if (savedOption) savedOption.selected = true;
                }
            } else {
                voiceSelect.disabled = true;
            }
        }
        // ブラウザによっては onvoiceschanged が一度しか呼ばれない、または呼ばれないことがあるため、遅延実行も加える
        populateVoiceList();
        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        /**
         * 指定されたテキストを音声で読み上げます。
         * @param {string} text - 読み上げるテキスト
         * @param {string} lang - 言語コード (e.g., 'ja-JP')
         */
        function speak(text, lang) {
            if ('speechSynthesis' in window && isVoiceGuidanceEnabled) {
                // 既存の発言があればキャンセル
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.rate = 1.1; // 少し早口に
                utterance.pitch = 1.0;

                const selectedVoiceName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
                if (selectedVoiceName) {
                    const selectedVoice = voices.find(voice => voice.name === selectedVoiceName);
                    if (selectedVoice) utterance.voice = selectedVoice;
                }

                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('このブラウザは音声合成をサポートしていません。');
            }
        }
        /**
         * UIの言語を設定します。
         * @param {string} lang - 言語コード ('ja' or 'en')
         */
        function setLanguage(lang) {
            if (!uiStrings[lang]) return;
            currentLang = lang;
            document.documentElement.lang = lang;

            // data-i18n属性を持つ静的なテキストを更新
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                if (uiStrings[lang][key]) {
                    el.textContent = uiStrings[lang][key];
                }
            });

            // data-i18n-placeholder属性を持つプレースホルダーを更新
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.dataset.i18nPlaceholder;
                if (uiStrings[lang][key]) {
                    el.placeholder = uiStrings[lang][key];
                }
            });

            // 検索ボックスのプレースホルダーを更新
            const searchInput = document.getElementById('pac-input');
            if (searchInput) {
                searchInput.placeholder = uiStrings[lang].searchForPlace || 'Search for a Place';
            }

            // 状態によってテキストが変わるボタンを更新
            toggleTourButton.textContent = isTourRunning ? uiStrings[lang].stopTour : uiStrings[lang].startTour;
            bleConnectButton.textContent = (bleDevice && bleDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectPower;
            hrConnectButton.textContent = (hrDevice && hrDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectHr;
            logToggleButton.textContent = isLogging ? uiStrings[lang].stopLog : uiStrings[lang].startLog;
            updateFullscreenButtonState();

            // マーカーのタイトルを更新
            if (startMarker) startMarker.setTitle(uiStrings[lang].startPoint);
            if (endMarker) endMarker.setTitle(uiStrings[lang].endPoint);
            if (currentLocationMarker) currentLocationMarker.setTitle(uiStrings[lang].currentLocation);

            // 声色の選択肢を更新
            populateVoiceList();

            // 言語スイッチャーボタンのアクティブ状態を更新
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.lang === lang));
        }

        // ドロップダウンの表示/非表示を切り替える
        routeSettingsButton.addEventListener('click', (event) => {
            if (isTourRunning || isLogging) {
                showMessage(uiStrings[currentLang].routeSettingsDisabled, true);
                return;
            }
            event.stopPropagation();
            routeSettingsDropdown.classList.toggle('show');
        });

        // ドロップダウン外をクリックしたら閉じる
        window.addEventListener('click', (event) => {
            if (routeSettingsDropdown.classList.contains('show') && !routeSettingsDropdown.contains(event.target) && !routeSettingsButton.contains(event.target)) {
                routeSettingsDropdown.classList.remove('show');
            }
            if (settingsDropdown.classList.contains('show') && !settingsContainer.contains(event.target)) {
                settingsDropdown.classList.remove('show');
            }
        });

        /**
         * 巡回モードを設定し、UIを更新します。
         * @param {string} mode - ツアーモード ('DRIVING', 'BICYCLING', 'WALKING')
         */
        function setTravelMode(mode) {
            currentTravelMode = mode;
            travelModeButtons.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            intervalInput.value = defaultSettings[mode].interval;
            speedInput.value = defaultSettings[mode].speed;
        }

        travelModeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                setTravelMode(btn.dataset.mode);
            });
        });

        directionButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                directionOffset = parseInt(btn.dataset.angle, 10);

                directionButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                if (!isTourRunning && routePoints.length > 0) {
                    updateStreetView();
                }
            });
        });

        // 手動ブーストボタンのクリックイベント
        boostButton.addEventListener('click', () => {
            isBoostActive = !isBoostActive;
            boostButton.classList.toggle('active', isBoostActive);
            boostButton.title = isBoostActive ? uiStrings[currentLang].boostOn : uiStrings[currentLang].boost;
        });

        // --- 設定メニュー関連のイベントリスナー ---
        settingsButton.addEventListener('click', (event) => {
            event.stopPropagation();
            settingsDropdown.classList.toggle('show');
        });

        voiceGuidanceToggle.addEventListener('change', () => {
            isVoiceGuidanceEnabled = voiceGuidanceToggle.checked;
            localStorage.setItem('isVoiceGuidanceEnabled', isVoiceGuidanceEnabled);
        });

        voiceSelect.addEventListener('change', () => {
            const selectedVoiceName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
            if (selectedVoiceName) {
                localStorage.setItem('selectedVoiceName', selectedVoiceName);
            }
        });

        geocodeIntervalInput.addEventListener('input', () => {
            const interval = parseInt(geocodeIntervalInput.value, 10);
            if (!isNaN(interval) && interval >= 100) {
                geocodeIntervalDistance = interval;
                localStorage.setItem('geocodeIntervalDistance', geocodeIntervalDistance);
            }
        });

        autoBoostThresholdInput.addEventListener('input', () => {
            const threshold = parseInt(autoBoostThresholdInput.value, 10);
            if (!isNaN(threshold)) {
                autoBoostThreshold = threshold;
                localStorage.setItem('autoBoostThreshold', autoBoostThreshold);
            }
        });

        /**
         * マップ上のすべてのマーカーをクリアします。
         */
        function clearMarkers() {
            if (startMarker) startMarker.setMap(null);
            if (endMarker) endMarker.setMap(null);
            if (currentLocationMarker) currentLocationMarker.setMap(null);
            startMarker = null;
            endMarker = null;
            currentLocationMarker = null;
        }

        /**
         * ツアー状態を初期化します。
         */
        function resetTourState() {
            stopTour();
            clearMarkers();
            directionsRenderer.setDirections({ routes: [] });
            if (gpxRoutePolyline) {
                gpxRoutePolyline.setMap(null);
                gpxRoutePolyline = null;
            }
            routePoints = [];
            routeElevations = [];
            routeGradients = [];
            totalDistance = 0;
            currentPositionDistance = 0;
            distanceTraveled = 0; // 走行距離もリセット
            currentPointIndex = 0;
            // パワーソースに接続されていない場合のみ、現在の移動モードのデフォルト速度を再設定
            if (!bleDevice || !bleDevice.gatt.connected) {
                speedInput.value = defaultSettings[currentTravelMode].speed;
            }
            document.getElementById('elevation').textContent = `N/A`;
            document.getElementById('gradient').textContent = `N/A`;
            updateInfoDisplay();
            toggleTourButton.disabled = true;

            // グラフをクリアして非表示にする
            const container = document.getElementById('elevation-chart-container');
            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            container.style.display = 'none';
        }

        /**
         * 経路データを処理し、マップとストリートビューを初期化します。
         * @param {google.maps.LatLng[]} path - 経路の座標の配列
         */
        async function processRoute(path) {
            routePoints = path;
            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noStreetView);
                return;
            }

            const firstPoint = routePoints[0];
            const lastPoint = routePoints[routePoints.length - 1];

            // 最初に全ポイントの累積距離を計算
            cumulativeDistances = [0];
            for (let i = 1; i < path.length; i++) {
                cumulativeDistances.push(cumulativeDistances[i - 1] + getDistance(path[i - 1], path[i]));
            }
            totalDistance = cumulativeDistances[cumulativeDistances.length - 1];

            try {
                // 1. 経路長に応じてサンプリング距離を動的に決定する
                const minSamplingDistance = 25;  // 最小サンプリング距離 (m)
                const maxSamplingDistance = 150; // 最大サンプリング距離 (m)
                let samplingDistance = (totalDistance >= 1000) ? (totalDistance * 0.025) : minSamplingDistance;
                samplingDistance = Math.min(samplingDistance, maxSamplingDistance);

                sampledPointsData = [{ point: path[0], distance: 0 }];
                let distanceSinceLastSample = 0;
                for (let i = 1; i < path.length; i++) {
                    const dist = cumulativeDistances[i] - cumulativeDistances[i-1];
                    distanceSinceLastSample += dist;
                    if (distanceSinceLastSample >= samplingDistance) {
                        sampledPointsData.push({ point: path[i], distance: cumulativeDistances[i] });
                        distanceSinceLastSample = 0;
                    }
                }
                // 最後のポイントがサンプリングされていない場合、追加する
                if (sampledPointsData[sampledPointsData.length - 1].distance < totalDistance) {
                    sampledPointsData.push({ point: path[path.length - 1], distance: totalDistance });
                }

                // 2. サンプリングした点の標高を取得
                const sampledPoints = sampledPointsData.map(d => d.point);
                const sampleLimit = 512; // APIの上限
                let allElevationResults = [];

                for (let i = 0; i < sampledPoints.length; i += sampleLimit) {
                    const chunk = sampledPoints.slice(i, i + sampleLimit);
                    const { results: chunkResults } = await elevationService.getElevationForLocations({
                        locations: chunk,
                    });
                    if (!chunkResults || chunkResults.length !== chunk.length) {
                        const errorMessage = chunkResults ? `Expected ${chunk.length} results but got ${chunkResults.length}.` : 'No results from API.';
                        throw new Error(`Elevation fetch error in chunk [${i}-${i+chunk.length-1}]: ${errorMessage}`);
                    }
                    allElevationResults = allElevationResults.concat(chunkResults);
                }

                if (allElevationResults.length !== sampledPoints.length) {
                    throw new Error('Failed to get elevation for all sampled points.');
                }
                sampledPointsData.forEach((data, i) => {
                    data.elevation = allElevationResults[i].elevation;
                });

                // 標高の異常なスパイクを除去するためにメディアンフィルタを適用
                // ウィンドウサイズを広げ、2回適用することでより強力にスパイクを除去する
                sampledPointsData = applyMedianFilter(sampledPointsData, 5);
                sampledPointsData = applyMedianFilter(sampledPointsData, 5);

                // 3. 元の経路の各点の標高を計算する
                routeElevations = new Array(path.length);

                // サンプリングされた点が2つ未満の場合（経路が非常に短い場合など）、
                // 全ポイントを最初の点の標高にするか、0で埋める
                if (sampledPointsData.length < 2) {
                    const singleElevation = sampledPointsData.length === 1 ? sampledPointsData[0].elevation : 0;
                    routeElevations.fill(singleElevation);
                } else {
                    // 線形補間で各点の標高を計算
                    let currentSegmentIndex = 0;
                    for (let i = 0; i < path.length; i++) {
                        const pointDistance = cumulativeDistances[i];
                        // 現在の点がどの補間セグメントに属するかを見つける
                        while (currentSegmentIndex < sampledPointsData.length - 2 && pointDistance > sampledPointsData[currentSegmentIndex + 1].distance) {
                            currentSegmentIndex++;
                        }
                        const startSample = sampledPointsData[currentSegmentIndex];
                        const endSample = sampledPointsData[currentSegmentIndex + 1];
                        const segmentDistance = endSample.distance - startSample.distance;
                        const distanceIntoSegment = pointDistance - startSample.distance;
                        const fraction = (segmentDistance > 0) ? distanceIntoSegment / segmentDistance : 0;
                        const interpolatedElevation = startSample.elevation + (endSample.elevation - startSample.elevation) * Math.max(0, Math.min(1, fraction));
                        routeElevations[i] = interpolatedElevation;
                    }
                }

                // 4. 元の経路の各点の勾配を計算する
                routeGradients = new Array(path.length);
                if (sampledPointsData.length >= 2) {
                    let currentSegmentIndex = 0;
                    let lastValidGradient = 0;
                    for (let i = 0; i < path.length; i++) {
                        const pointDistance = cumulativeDistances[i];
                        while (currentSegmentIndex < sampledPointsData.length - 2 && pointDistance > sampledPointsData[currentSegmentIndex + 1].distance) {
                            currentSegmentIndex++;
                        }
                        const startSample = sampledPointsData[currentSegmentIndex];
                        const endSample = sampledPointsData[currentSegmentIndex + 1];
                        const segmentDistance = endSample.distance - startSample.distance;
                        const elevationChange = endSample.elevation - startSample.elevation;

                        if (segmentDistance >= 1.0) { // 1m以上の場合のみ計算
                            lastValidGradient = (elevationChange / segmentDistance) * 100;
                        }
                        routeGradients[i] = lastValidGradient;
                    }
                } else {
                    routeGradients.fill(0);
                }
                showMessage(uiStrings[currentLang].elevationProcessed, false);
            } catch (error) {
                showMessage(uiStrings[currentLang].elevationError, true);
                console.error("Elevation processing error:", error);
                routeElevations = new Array(routePoints.length).fill(0);
            }

            startMarker = new google.maps.Marker({
                map: map,
                position: firstPoint,
                title: uiStrings[currentLang].startPoint,
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, // 三角形
                    scale: 7,
                    fillColor: '#2ecc71', // 緑色
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: '#ffffff', // 白い縁取り
                    rotation: 90 // 上向きにする
                },
                zIndex: 1000
            });
            endMarker = new google.maps.Marker({
                map: map,
                position: lastPoint,
                title: uiStrings[currentLang].endPoint,
                icon: {
                    path: 'M -5,-5 5,-5 5,5 -5,5 Z', // 四角形
                    scale: 1.5,
                    fillColor: '#e74c3c', // 赤色
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: '#ffffff' // 白い縁取り
                },
                zIndex: 1000
            });
            currentLocationMarker = new google.maps.Marker({
                map: map,
                title: uiStrings[currentLang].currentLocation,
                // アイコンとしてSVG画像を直接指定する (データURI形式)
                icon: {
                    url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 384 512">
                            <path fill="#2ecc71" d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67a24 24 0 0 1-35.464 0z"/>
                            <circle cx="192" cy="192" r="64" fill="white"/>
                        </svg>
                    `)}`,
                    scaledSize: new google.maps.Size(36, 48), // 表示サイズ
                    anchor: new google.maps.Point(18, 48)     // ピンの先端の位置
                },
                position: firstPoint,
                zIndex: 9999,
            });

            if (panorama) {
                panorama.setPosition(firstPoint);
                map.panTo(firstPoint);

                try {
                    if (routePoints.length > 1) {
                        const heading = getHeading(routePoints[0], routePoints[1]);
                        if (!isNaN(heading)) {
                            panorama.setPov({ heading: (heading + directionOffset + 360) % 360, pitch: 0 });
                        }
                    }
                } catch (e) {
                    console.error("Error setting initial POV:", e);
                }
            }

            showMessage(uiStrings[currentLang].routeFound, false);
            // 経路の開始地点を出発地として設定する
            setOriginToGeocodedLocation(firstPoint);

            updateInfoDisplay();
            toggleTourButton.disabled = false;

            document.getElementById('elevation-chart').style.cursor = 'pointer';
            // 初期グラフを描画 (現在地は0)
            drawElevationChart(0);
        }

        /**
         * ユーザー入力に基づいて経路を計算し表示します。
         */
        function calculateAndDisplayRoute() {
            resetTourState();

            const originValue = originInput.value;
            const destinationValue = destinationInput.value;
            const interpolationInterval = parseFloat(intervalInput.value);

            if (!originValue || !destinationValue) {
                showMessage(uiStrings[currentLang].originDestRequired);
                return;
            }
            if (isNaN(interpolationInterval) || interpolationInterval <= 0) {
                showMessage(uiStrings[currentLang].invalidInterval);
                return;
            }

            const origin = originLatLng || originValue;
            const destination = destinationLatLng || destinationValue;

            directionsService.route({
                origin: origin,
                destination: destination,
                travelMode: google.maps.TravelMode[currentTravelMode],
            }).then((response) => {
                if (response.status === 'OK') {                    
                    // 経路の色を赤に変更 (既に適用済みですが、確認のため記載)
                    directionsRenderer.setOptions({
                        polylineOptions: { strokeColor: '#e74c3c', strokeWeight: 5, strokeOpacity: 0.8 }
                    });
                    // overview_pathの代わりに、より詳細なstepsのpathを連結して使用する
                    const detailedPath = response.routes[0].legs.flatMap(leg => leg.steps.flatMap(step => step.path));
                    directionsRenderer.setDirections(response);

                    const interpolatedPath = [];
                    for (let i = 0; i < detailedPath.length - 1; i++) {
                        const p1 = detailedPath[i];
                        const p2 = detailedPath[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / interpolationInterval);
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                        }
                    }
                    interpolatedPath.push(detailedPath[detailedPath.length - 1]);

                    processRoute(interpolatedPath);
                } else {
                    throw new Error(`${uiStrings[currentLang].routeSearchFailed}${response.status}`);
                }
            }).catch((e) => {
                showMessage(uiStrings[currentLang].routeNotFound);
            });
        }

        loadGpxButton.addEventListener('click', () => {
            gpxFileInput.click();
        });

        gpxFileInput.addEventListener('change', (event) => {
            resetTourState();

            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxText = e.target.result;
                    const parser = new DOMParser();
                    const gpxDoc = parser.parseFromString(gpxText, 'application/xml');

                    const trkpts = gpxDoc.querySelectorAll('trkpt');
                    if (trkpts.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoTrackpoints);
                        return;
                    }

                    const gpxPoints = [];
                    trkpts.forEach(pt => {
                        const lat = parseFloat(pt.getAttribute('lat'));
                        const lon = parseFloat(pt.getAttribute('lon'));
                        if (!isNaN(lat) && !isNaN(lon)) {
                            gpxPoints.push(new google.maps.LatLng(lat, lon));
                        }
                    });

                    if (gpxPoints.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoCoordinates);
                        return;
                    }

                    const interpolationInterval = parseFloat(intervalInput.value);
                    const interpolatedPath = [];
                    for (let i = 0; i < gpxPoints.length - 1; i++) {
                        const p1 = gpxPoints[i];
                        const p2 = gpxPoints[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / interpolationInterval);
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                        }
                    }
                    interpolatedPath.push(gpxPoints[gpxPoints.length - 1]);

                    gpxRoutePolyline = new google.maps.Polyline({
                        path: interpolatedPath,
                        geodesic: true,
                        strokeColor: '#e74c3c', // 赤色に変更
                        strokeOpacity: 0.8,
                        strokeWeight: 5
                    });
                    gpxRoutePolyline.setMap(map);

                    processRoute(interpolatedPath);
                } catch (error) {
                    showMessage(uiStrings[currentLang].gpxParseError);
                }
            };
            reader.readAsText(file);
        });

        async function updateStreetView() {
            if (routePoints.length === 0 || currentPointIndex >= routePoints.length) return;

            const targetPosition = routePoints[currentPointIndex];

            try {
                const { data } = await streetViewService.getPanorama({
                    location: targetPosition,
                    radius: 100,
                    source: showUserContent ? google.maps.StreetViewSource.DEFAULT : google.maps.StreetViewSource.GOOGLE,
                    preference: google.maps.StreetViewPreference.NEAREST
                });

                if (data && data.location) {
                    const currentPanoId = panorama.getPano();
                    const newPanoId = data.location.pano;

                    if (newPanoId && newPanoId !== currentPanoId) {
                        panorama.setPosition(data.location.latLng);
                    }

                    if (currentPointIndex + 1 < routePoints.length) {
                        const heading = getHeading(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]);
                        if (!isNaN(heading)) {
                            panorama.setPov({ heading: (heading + directionOffset + 360) % 360, pitch: 0 });
                        }
                    }
                } else {
                    console.log(`No panorama found near point ${currentPointIndex}. Skipping Street View update.`);
                }
            } catch (e) {
                console.error(`Error getting panorama data for point ${currentPointIndex}:`, e);
                if (e.code) console.error(`Street View API Error Code: ${e.code}`);
            }
        }

        function updatePhysics() {
            if (!isTourRunning) return; 

            const now = Date.now();
            const deltaTime = (now - lastPhysicsUpdateTime) / 1000; // 秒単位
            lastPhysicsUpdateTime = now;

            // パワーソースが接続されている場合は物理モデルに基づいて速度を更新
            if (bleDevice && bleDevice.gatt.connected) {
                const C = PHYSICS_CONSTANTS;

                // 1. 抵抗力の計算
                const gradientAngle = Math.atan(currentGradient / 100);
                const rollingResistanceForce = C.CRR * C.TOTAL_MASS * C.G * Math.cos(gradientAngle);
                const airResistanceForce = 0.5 * C.CDA * C.RHO * Math.pow(currentSpeedMps, 2);
                const gradientResistanceForce = C.TOTAL_MASS * C.G * Math.sin(gradientAngle);
                const totalResistanceForce = rollingResistanceForce + airResistanceForce + gradientResistanceForce;

                // 2. 推進力の計算
                // 速度が非常に遅い場合の発散を防ぐ
                const effectiveSpeed = Math.max(currentSpeedMps, C.MIN_SPEED_FOR_FORCE_CALC_MPS);
                const boostedPower = isBoostActive ? currentPower * BOOST_FACTOR : currentPower;
                const propulsiveForce = (boostedPower * C.DRIVETRAIN_EFFICIENCY) / effectiveSpeed;

                // オートブーストのロジック
                if (autoBoostThreshold > 0) {
                    if (currentGradient >= autoBoostThreshold) {
                        isBoostActive = true;
                    } else {
                        isBoostActive = false;
                    }
                    boostButton.classList.toggle('active', isBoostActive);
                }
                // 3. 加速度と新しい速度の計算
                const netForce = propulsiveForce - totalResistanceForce;
                const acceleration = netForce / C.TOTAL_MASS;
                currentSpeedMps += acceleration * deltaTime;
                currentSpeedMps = Math.max(0, currentSpeedMps); // 速度が負にならないように

                // UIの速度表示を更新
                speedInput.value = (currentSpeedMps * 3.6).toFixed(1);

                // ツアー停止条件のチェック
                if (currentSpeedMps * 3.6 < C.STOPPING_SPEED_KMH && currentPower <= 0) {
                    stopTour();
                    showMessage(uiStrings[currentLang].powerZeroStop, false); // エラーではなく情報として表示
                    return;
                }

            } else {
                // パワーソースが接続されていない場合は、手動入力された速度を使用
                const speedKmh = parseFloat(speedInput.value) || 0;
                currentSpeedMps = speedKmh / 3.6;
            }

            const deltaDistance = currentSpeedMps * deltaTime;
            currentPositionDistance += deltaDistance;
            distanceTraveled += deltaDistance; // 実際に走行した距離も加算
            distanceSinceLastGeocode += deltaDistance;
            distanceSinceLastSvUpdate += deltaDistance;

            if (currentPositionDistance >= totalDistance) {
                currentPositionDistance = totalDistance;
                currentPointIndex = routePoints.length - 1;
                if (currentLocationMarker && routePoints.length > 0) {
                    currentLocationMarker.setPosition(routePoints[currentPointIndex]);
                }
                updateInfoDisplay();
                stopTour();
                announceLocation(routePoints[currentPointIndex], 'arrival');
                showMessage(uiStrings[currentLang].destinationReached, false);
                return;
            }

            // 現在のインデックスを更新
            while (currentPointIndex < cumulativeDistances.length - 1 && currentPositionDistance > cumulativeDistances[currentPointIndex + 1]) {
                currentPointIndex++;
            }

            const currentPosition = routePoints[currentPointIndex];
            currentLocationMarker.setPosition(currentPosition);
            map.panTo(currentPosition);

            updateInfoDisplay();

            if (distanceSinceLastSvUpdate >= STREETVIEW_UPDATE_DISTANCE) {
                updateStreetView();
                distanceSinceLastSvUpdate = 0;
            }

            if (distanceSinceLastGeocode >= geocodeIntervalDistance) {
                announceLocation(currentPosition, 'moving');
                distanceSinceLastGeocode = 0;
            }

            if (isLogging) {
                const currentElevation = (routeElevations.length > currentPointIndex) ? routeElevations[currentPointIndex] : 0;
                logData.push({
                    timestamp: new Date().toISOString(),
                    position: currentPosition,
                    elevation: currentElevation,
                    power: currentPower,
                    cadence: currentCadence,
                    heartRate: currentHeartRate,
                    distance: distanceTraveled, // ログには実際に走行した総距離を記録
                    speed: currentSpeedMps * 3.6 // km/hで記録
                });
            }
        }

        /**
         * 指定された距離にツアーの現在地をジャンプさせます。
         * @param {number} newDistance - ジャンプ先の距離 (m)
         */
        function jumpToDistance(newDistance) {
            if (routePoints.length < 2) return;

            // 距離を経路の範囲内に収める
            newDistance = Math.max(0, Math.min(newDistance, totalDistance));
            currentPositionDistance = newDistance;

            // 新しい現在地のインデックスを探す
            let newIndex = 0;
            while (newIndex < cumulativeDistances.length - 1 && newDistance > cumulativeDistances[newIndex + 1]) {
                newIndex++;
            }
            currentPointIndex = newIndex;

            // マーカーの位置を即時更新
            const newPosition = routePoints[currentPointIndex];
            if (currentLocationMarker) {
                currentLocationMarker.setPosition(newPosition);
                map.panTo(newPosition);
            }
            
            // ストリートビューを即時更新
            updateStreetView();

            // ジャンプした地点を出発地として設定
            setOriginToGeocodedLocation(newPosition);

            // 情報表示とグラフを更新
            updateInfoDisplay();
        }
         /**
         * 指定された座標の地名を取得し、状況に応じた音声ガイダンスを再生します。
         * @param {google.maps.LatLng} location - 確認する場所の座標
         * @param {'departure' | 'moving' | 'arrival'} context - 'departure' (出発時), 'moving' (移動中), 'arrival' (到着時)
         */
        async function announceLocation(location, context) {
            if (!geocoder || !isVoiceGuidanceEnabled) return;

            try {
                const { results } = await geocoder.geocode({ location: location, language: currentLang });
                if (!results || !results[0]) return;
               // デバッグ用に取得した住所情報をコンソールに出力
                console.log('Geocoding Result:', results[0]?.formatted_address, results[0]?.address_components);

                const addressComponents = results[0].address_components;
                let prefecture = '', locality = '', sublocality = '';

                for (const component of addressComponents) {
                    if (component.types.includes('administrative_area_level_1')) {
                        prefecture = component.long_name;
                    }
                    if (locality === '' && component.types.includes('locality')) {
                        locality = component.long_name;
                    }
                    if (locality === '' && component.types.includes('administrative_area_level_2')) {
                        locality = component.long_name;
                    }
                    if (sublocality === '' && component.types.includes('sublocality_level_2')) {
                        sublocality = component.long_name;
                    }
                }
                const locationName = locality + sublocality;
                if (!locationName) return; // アナウンスに必要な地名がなければ終了

                if (context === 'departure') {
                    const message = (uiStrings[currentLang].departingFrom || '{location} から出発します。').replace('{location}', locationName);
                    speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                } else if (context === 'moving') {
                    // 「町」レベルの地名が取得できた場合のみ比較・アナウンス
                    const newFullMunicipality = sublocality ? (prefecture + locality + sublocality) : '';

                    if (newFullMunicipality && newFullMunicipality !== currentMunicipality) {
                        if (currentMunicipality !== '') { // 初回はメッセージを表示しない
                            const messageTemplate = uiStrings[currentLang].municipalityGuidance || '{municipality} を移動中です。';
                            const message = messageTemplate.replace('{municipality}', locationName);
                            showMessage(message, false); // 緑色のメッセージボックス
                            speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                        }
                        currentMunicipality = newFullMunicipality;
                    }
                } else if (context === 'arrival') {
                    const message = (uiStrings[currentLang].arrivedAt || '{location} に到着しました。おつかれさまでした。').replace('{location}', locationName);
                    speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                }
            } catch (e) {
                console.error(`Geocoding failed during location announcement ('${context}'):`, e);
            }
        }
        /**
         * 標高グラフのクリックイベントを処理します。
         * @param {MouseEvent} event - クリックイベント
         */
        function handleChartClick(event) {
            if (isTourRunning) {
                showMessage(uiStrings[currentLang].jumpDisabledDuringTour);
                return;
            }
            if (routePoints.length < 2) return;

            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;

            const padding = { top: 15, bottom: 30, left: 40, right: 40 };
            const chartWidth = canvas.clientWidth - padding.left - padding.right;

            if (x < padding.left || x > canvas.clientWidth - padding.right) {
                return;
            }

            const clickedX = x - padding.left;
            const fraction = Math.max(0, Math.min(1, clickedX / chartWidth));
            const newDistance = totalDistance * fraction;

            jumpToDistance(newDistance);
        }

        /**
         * 画面のスリープを防止するWake Lockを要求します。
         */
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockSentinel.addEventListener('release', () => {
                        // システムによってロックが解放された場合（例：タブの非表示化）
                        console.log('Screen Wake Lock was released by the system.');
                        wakeLockSentinel = null;
                    });
                    console.log('Screen Wake Lock is active.');
                } catch (err) {
                    console.error(`Failed to acquire wake lock: ${err.name}, ${err.message}`);
                }
            }
        };

        /**
         * Wake Lockを解放します。
         */
        const releaseWakeLock = async () => {
            if (wakeLockSentinel !== null) {
                await wakeLockSentinel.release();
                wakeLockSentinel = null;
                console.log('Screen Wake Lock released.');
            }
        };

        async function toggleTour() {
            if (isTourRunning) {
                await stopTour();
            } else {
                await startTour();
            }
        }

        async function startTour() {
            if (isTourRunning) return;

            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noRouteForTour);
                return;
            }

            // パワーソースが接続されていない場合のみ、手動速度をチェック
            if (!(bleDevice && bleDevice.gatt.connected)) {
                const speed = parseFloat(speedInput.value);
                if (isNaN(speed) || speed <= 0) {
                    showMessage(uiStrings[currentLang].invalidSpeed, true);
                    return;
                }
                currentSpeedMps = speed / 3.6;
            } else {
                currentSpeedMps = 0; // パワーソース接続時は0からスタート
            }

            // 画面のスリープを防止
            await requestWakeLock();
            isTourRunning = true;
            toggleTourButton.textContent = uiStrings[currentLang].stopTour;
            tourStartTime = Date.now();
            lastPhysicsUpdateTime = Date.now();
            distanceSinceLastSvUpdate = 0;

            map.setZoom(17);

            // 出発地の地名を取得してアナウンス
            if (routePoints.length > 0) {
                announceLocation(routePoints[currentPointIndex], 'departure');
            }

            physicsIntervalId = setInterval(updatePhysics, PHYSICS_INTERVAL_MS);
        }

        async function stopTour() {
            if (physicsIntervalId) {
                clearInterval(physicsIntervalId);
                physicsIntervalId = null;
            }
            isTourRunning = false;
            currentSpeedMps = 0;

            // 画面のスリープ防止を解除
            await releaseWakeLock();

            if (tourStartTime > 0) {
                totalTimeElapsed = totalTimeElapsed + (Date.now() - tourStartTime) / 1000;
                //console.log(formatTime(Date.now()));
                //console.log(formatTime(tourStartTime));
                //console.log(formatTime(totalTimeElapsed));
                tourStartTime = 0;
            }
            toggleTourButton.textContent = uiStrings[currentLang].startTour;
            updateInfoDisplay(); // UIとグラフの状態を更新

            // ツアー停止地点を次の出発地として設定
            if (currentLocationMarker) {
                setOriginToGeocodedLocation(currentLocationMarker.getPosition());
            }
        }

        async function connectToBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                await disconnectFromBleDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingDevice, false);
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [FTMS_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingDevice, false);
                const server = await bleDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const ftmsService = await server.getPrimaryService(FTMS_SERVICE_UUID);
                ftmsCharacteristic = await ftmsService.getCharacteristic(INDOOR_BIKE_DATA_UUID);

                await ftmsCharacteristic.startNotifications();
                ftmsCharacteristic.addEventListener('characteristicvaluechanged', handleFTMSData);

                showMessage(uiStrings[currentLang].ftmsConnected, false);
                bleConnectButton.textContent = uiStrings[currentLang].disconnect;
                bleConnectButton.style.backgroundColor = '#e74c3c';
                speedInput.readOnly = true; // 速度入力を読み取り専用に
                speedInput.value = 0; // 速度を0にクリア
                boostButton.style.display = 'block'; // ブーストボタンを表示
                boostButton.title = uiStrings[currentLang].boost;

            } catch (error) {
                console.error(`${uiStrings[currentLang].btConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].btConnectionError}${error.message}`);
                bleConnectButton.textContent = uiStrings[currentLang].connectPower;
                bleConnectButton.style.backgroundColor = '#3498db';
                bleDevice = null;
                ftmsCharacteristic = null;
            }
        }

        async function disconnectFromBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].deviceDisconnected, false);
            }
            if (ftmsCharacteristic) {
                ftmsCharacteristic.removeEventListener('characteristicvaluechanged', handleFTMSData);
                ftmsCharacteristic = null;
            }
            bleConnectButton.textContent = uiStrings[currentLang].connectPower;
            bleConnectButton.style.backgroundColor = '#3498db';
            speedInput.readOnly = false; // 速度入力を編集可能に戻す
            speedInput.value = 0;
            boostButton.style.display = 'none'; // ブーストボタンを非表示
            isBoostActive = false;
            boostButton.classList.remove('active');
            document.getElementById('power-display').textContent = '0 W';
            document.getElementById('cadence-display').textContent = '0 rpm';
            await stopTour(); // 切断時にツアーを停止
        }

        async function connectToHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                disconnectFromHrDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingHr, false);
                hrDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [HR_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingHr, false);
                const server = await hrDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const hrService = await server.getPrimaryService(HR_SERVICE_UUID);
                hrCharacteristic = await hrService.getCharacteristic(HR_MEASUREMENT_UUID);

                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);

                showMessage(uiStrings[currentLang].hrConnected, false);
                hrConnectButton.textContent = uiStrings[currentLang].disconnect;
                hrConnectButton.style.backgroundColor = '#e74c3c';

            } catch (error) {
                console.error(`${uiStrings[currentLang].hrConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].hrConnectionError}${error.message}`);
                hrConnectButton.textContent = uiStrings[currentLang].connectHr;
                hrConnectButton.style.backgroundColor = '#3498db';
                hrDevice = null;
                hrCharacteristic = null;
            }
        }

        function disconnectFromHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                hrDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].hrDisconnected, false);
            }
            if (hrCharacteristic) {
                hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                hrCharacteristic = null;
            }
            hrConnectButton.textContent = uiStrings[currentLang].connectHr;
            hrConnectButton.style.backgroundColor = '#3498db';
            document.getElementById('hr-display').textContent = '0 bpm';
        }

        /**
         * BLEから受信した心拍数データを処理します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            const rate16Bits = (flags & 0x1) !== 0;
            let heartRate;
            if (rate16Bits) {
                heartRate = value.getUint16(1, true); // Little endian
            } else {
                heartRate = value.getUint8(1);
            }
            currentHeartRate = heartRate;
            document.getElementById('hr-display').textContent = `${currentHeartRate} bpm`;
        }

        /**
         * ログ記録の開始/終了を切り替えます。
         */
        function toggleLogging() {
            isLogging = !isLogging;
            if (isLogging) {
                logData = []; // ログを初期化
                logStartDistance = distanceTraveled; // ログ開始時の走行距離を記録
                logStartTime = Date.now(); // ログ開始時刻を記録
                logToggleButton.textContent = uiStrings[currentLang].stopLog;
                logToggleButton.style.backgroundColor = '#f39c12'; // 記録中を示す色
                showMessage(uiStrings[currentLang].logStarted, false);
            } else {
                logToggleButton.textContent = uiStrings[currentLang].startLog;
                logToggleButton.style.backgroundColor = '#3498db';
                showMessage(uiStrings[currentLang].logStopped, false);
                if (logData.length > 1) { // データが2点以上ないとLapが作れない
                    if (confirm(uiStrings[currentLang].confirmSaveTcx)) {
                        saveLogAsTcx();
                    }
                }
            }
        }

        /**
         * 記録したログをTCXファイルとして保存します。
         */
        function saveLogAsTcx() {
            let maxSpeedMs = 0; // m/s単位での最大速度

            let trackpointsXml = logData.map(p => {
                let positionXml = '';
                if (p.position) {
                    positionXml = `
            <Position>
              <LatitudeDegrees>${p.position.lat()}</LatitudeDegrees>
              <LongitudeDegrees>${p.position.lng()}</LongitudeDegrees>
            </Position>`;
                }

                let altitudeXml = '';
                if (p.elevation !== undefined) {
                    altitudeXml = `
            <AltitudeMeters>${p.elevation.toFixed(2)}</AltitudeMeters>`;
                }

                const speedMs = p.speed ? (p.speed * 1000 / 3600) : 0;
                if (speedMs > maxSpeedMs) {
                    maxSpeedMs = speedMs;
                }

                // Garmin拡張スキーマ(TPX)に速度を追加
                const tpxExtensions = `
              <TPX xmlns="http://www.garmin.com/xmlschemas/ActivityExtension/v2">
                <Watts>${p.power}</Watts>
                <Speed>${speedMs.toFixed(2)}</Speed>
              </TPX>`;

                return `
          <Trackpoint>
            <Time>${p.timestamp}</Time>${positionXml}${altitudeXml}
            <DistanceMeters>${p.distance.toFixed(2)}</DistanceMeters>
            <HeartRateBpm>
              <Value>${p.heartRate}</Value>
            </HeartRateBpm>
            <Cadence>${p.cadence}</Cadence>
            <Extensions>
              ${tpxExtensions}
            </Extensions>
          </Trackpoint>`;
            }).join('');

            const lapStartTimeISO = new Date(logStartTime).toISOString();
            const logEndTime = Date.now();
            const totalTimeSeconds = (logEndTime - logStartTime) / 1000;
            const totalDistanceMeters = distanceTraveled - logStartDistance;

            const tcxContent = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xsi:schemaLocation="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd" xmlns:ns5="http://www.garmin.com/xmlschemas/ActivityGoals/v1" xmlns:ns3="http://www.garmin.com/xmlschemas/ActivityExtension/v2" xmlns:ns2="http://www.garmin.com/xmlschemas/UserProfile/v2" xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ns4="http://www.garmin.com/xmlschemas/ProfileExtension/v1">
  <Activities>
    <Activity Sport="Biking">
      <Id>${lapStartTimeISO}</Id>
      <Lap StartTime="${lapStartTimeISO}">
        <TotalTimeSeconds>${totalTimeSeconds.toFixed(0)}</TotalTimeSeconds>
        <DistanceMeters>${totalDistanceMeters.toFixed(2)}</DistanceMeters>
        <MaximumSpeed>${maxSpeedMs.toFixed(2)}</MaximumSpeed>
        <Calories>0</Calories>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>${trackpointsXml}</Track>
      </Lap>
    </Activity>
  </Activities>
</TrainingCenterDatabase>`;

            const blob = new Blob([tcxContent], { type: 'application/vnd.garmin.tcx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;            const date = new Date(logStartTime);
            const filename = `activity_${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}.tcx`;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * BLEから受信したFTMSデータを処理します。
         * 速度を動的に計算し、UIを更新します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleFTMSData(event) {
            const value = event.target.value;
            const data = new DataView(value.buffer);
            const rawData = Array.from(new Uint8Array(data.buffer)).join(' ');

            const flags = data.getUint16(0, true);
            let offset = 2;

            if (flags & 0x01) {
            }
            if (flags & 0x02) {
                offset += 2;
            }
            if (flags & 0x04) {
                const instantaneousCadence = data.getUint16(offset, true) / 2;
                currentCadence = instantaneousCadence.toFixed(0);
                document.getElementById('cadence-display').textContent = `${currentCadence} rpm`;
                offset += 2;
            }
            if (flags & 0x08) {
                offset += 2;
            }
            if (flags & 0x10) {
                offset += 3;
            }
            if (flags & 0x20) {
                offset += 2;
            }
            if (flags & 0x40) {
                const power = data.getInt16(offset, true);
                currentPower = power;
                document.getElementById('power-display').textContent = `${currentPower} W`;

                // ツアーが実行中でなく、パワーが検出されたらツアーを開始
                if (!isTourRunning && power > 0) {
                    startTour();
                    showMessage(uiStrings[currentLang].powerDetectedStart, false);
                }
                offset += 2;
            }
            if (flags & 0x80) {
                offset += 2;
            }
        }

        /**
         * 指定された場所にマップとストリートビューを移動させます。
         * @param {google.maps.places.PlaceResult} place - 移動先の場所情報
         */
        function jumpToPlace(place) {
            if (!place || !place.geometry || !place.geometry.location) return;

            const location = place.geometry.location;

            // 既存の経路やマーカーをクリア
            resetTourState();

            map.setCenter(location);
            map.setZoom(17);
            panorama.setPosition(location);

            // ストリートビューの向きを調整（利用可能な場合）
            streetViewService.getPanorama({ location: location, radius: 50 })
                .then(({ data }) => {
                    if (data && data.links && data.links.length > 0 && data.links[0].pano) {
                        // 最も近い道路の方向に向ける
                        const heading = google.maps.geometry.spherical.computeHeading(location, data.links[0].pano);
                        panorama.setPov({ heading: heading, pitch: 0, zoom: 1 });
                    } else {
                        panorama.setPov({ heading: 0, pitch: 0, zoom: 1 });
                    }
                })
                .catch(e => console.error("Could not set POV for jumped location:", e));
        }

        /**
         * formatted_addressから国名と郵便番号を除去して整形します。
         * @param {string} formattedAddress - Google Geocoding APIから返されるformatted_address
         * @param {Array<Object>} addressComponents - Google Geocoding APIから返されるaddress_components
         * @returns {string} - 整形された住所文字列
         */
        function formatAddress(formattedAddress, addressComponents) {
            // addressComponentsがなければ、元のformattedAddressをそのまま返す
            if (!addressComponents) return formattedAddress || '';

            // 日本語環境を優先し、住所を構成する要素を定義
            const desiredTypes = [
                'administrative_area_level_1', // 都道府県
                'locality',                      // 市区町村
                'sublocality_level_1',           // 区 (例: 東京都千代田区)
                'sublocality_level_2',           // 〇〇町
                'sublocality_level_3',           // 〇〇丁目
                'sublocality_level_4'            // 番地など
            ];

            const addressParts = [];
            for (const type of desiredTypes) {
                const component = addressComponents.find(c => c.types.includes(type));
                if (component && !addressParts.includes(component.long_name)) {
                    addressParts.push(component.long_name);
                }
            }

            // 連結した結果が空なら、元のformattedAddressを返す
            return addressParts.length > 0 ? addressParts.join('') : formattedAddress;
        }

        /**
         * 指定された座標を逆ジオコーディングし、結果を分析して最適な地名を出発地として設定します。
         * 施設名があればそれを優先し、なければ住所を設定します。
         * @param {google.maps.LatLng} location - 出発地として設定する座標
         */
        async function setOriginToGeocodedLocation(location) {
            if (!location) return;

            originLatLng = location;

            try {
                const { results } = await geocoder.geocode({ location: location, language: currentLang });
                if (results && results.length > 0) {
                    // 最初の結果の住所を整形して使用する
                    originInput.value = formatAddress(results[0].formatted_address, results[0].address_components);
                }
            } catch (e) {
                console.error("Geocoding failed for new origin:", e);
            }
        }

        async function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: initialLocation,
                zoom: 12,
                streetViewControl: false, // ストリートビューのペグマンを非表示
                mapTypeControl: false,    // デフォルトのマップ/航空写真コントロールを非表示
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                    position: google.maps.ControlPosition.LEFT_BOTTOM // 新しい位置を指定
                }
            });
            
            // 以下の初期化はmapオブジェクトが生成された後に行う
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({ map: map, suppressMarkers: true });
            elevationService = new google.maps.ElevationService();
            geocoder = new google.maps.Geocoder();
            streetViewService = new google.maps.StreetViewService();

            // localStorageからホーム地点を読み込み、設定する
            const savedHome = localStorage.getItem('streetMoViewHomeLocation');
            if (savedHome) {
                try {
                    const homeCoords = JSON.parse(savedHome);
                    if (homeCoords && typeof homeCoords.lat === 'number' && typeof homeCoords.lng === 'number') {
                        initialLocation = homeCoords;
                        map.setCenter(initialLocation);
                        // 新しい関数を使って出発地を設定
                        await setOriginToGeocodedLocation(new google.maps.LatLng(homeCoords.lat, homeCoords.lng));
                    }
                } catch (e) {
                    console.error("Failed to parse or geocode home location from localStorage", e);
                    localStorage.removeItem('streetMoViewHomeLocation');
                }
            }

            // 地図上に検索ボックスを作成して配置
            const searchInput = document.createElement('input');
            searchInput.id = 'pac-input';
            searchInput.type = 'text';
            searchInput.placeholder = '場所を検索';
            searchInput.style.cssText = 'background-color: #fff; font-family: Roboto; font-size: 15px; font-weight: 300; margin: 10px 0 10px 10px; padding: 5px 10px; width: 300px; border: 1px solid #ccc; box-shadow: 0 2px 6px rgba(0,0,0,0.3); border-radius: 3px;';
            
            const searchBox = new google.maps.places.SearchBox(searchInput);
            map.controls[google.maps.ControlPosition.TOP_LEFT].push(searchInput);

            // 検索ボックスのプレースホルダーを初期設定
            searchInput.placeholder = uiStrings[currentLang].searchForPlace;
            panorama = new google.maps.StreetViewPanorama(document.getElementById('street-view'), {
                position: initialLocation,
                visible: true,
                pov: { heading: 0, pitch: 0, zoom: 1 },
                source: google.maps.StreetViewSource.DEFAULT // 初期状態ではユーザー投稿も表示
            });

            map.setStreetView(panorama);

            // SearchBoxで場所が選択されたときのリスナー
            streetViewCoverageLayer = new google.maps.StreetViewCoverageLayer();

            // SearchBoxで場所が選択されたときのリスナー
            // カスタムのマップタイプコントロールを先に有効にする
            map.setOptions({ mapTypeControl: true });

            // マップ左下のコントロールを配置
            const mapControlsContainer = document.getElementById('map-controls-container');
            map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(mapControlsContainer);

            mapControlsContainer.style.display = 'flex'; // 表示を有効にする

            searchBox.addListener('places_changed', () => {
                const places = searchBox.getPlaces();

                if (places.length == 0) {
                    return;
                }

                // 最初の場所を取得してジャンプ
                jumpToPlace(places[0]);
            });

            // POIクリックで情報ウィンドウを表示し、出発地/目的地に設定する機能
            placesService = new google.maps.places.PlacesService(map);
            infoWindow = new google.maps.InfoWindow({
                // InfoWindow内のコンテンツがはみ出ないように最大幅を設定
                maxWidth: 350
            });

            map.addListener('click', (e) => {
                // クリックした場所に既にInfoWindowが開いていたら閉じる
                infoWindow.close();
                selectedPlace = null;

                if (e.placeId) {
                    e.stop(); // デフォルトのPOI情報ウィンドウの表示を停止

                    placesService.getDetails({ placeId: e.placeId }, (place, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && place && place.geometry && place.geometry.location) {
                            selectedPlace = place; // クリックされた場所の情報を保持

                            // 出発地が入力されているかチェック
                            const isOriginSet = originInput.value.trim() !== '' || originLatLng !== null;
                            const setDestButtonText = isOriginSet ? uiStrings[currentLang].setAsDestinationAndSearch : uiStrings[currentLang].setAsDestination;
                            const setDestButtonId = isOriginSet ? 'set-dest-and-search-btn' : 'set-dest-btn';

                            // 出発地が設定されていれば、直線距離を計算して表示
                            let distanceInfoHtml = '';
                            if (originLatLng) {
                                const distanceInMeters = google.maps.geometry.spherical.computeDistanceBetween(originLatLng, place.geometry.location);
                                const distanceInKm = (distanceInMeters / 1000).toFixed(2);
                                distanceInfoHtml = `<div style="font-size: 12px; color: #777; margin-top: 8px;">現在地からの直線距離: 約 ${distanceInKm} km</div>`;
                            }


                            // InfoWindowに表示するHTMLコンテンツを生成
                            const content = `
                                <div style="color: #333; font-family: 'Inter', sans-serif; line-height: 1.5;">
                                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 4px;">${place.name}</div>
                                    ${place.formatted_address ? `<div style="font-size: 13px; color: #555; margin-bottom: 12px;">${place.formatted_address}</div>` : ''}
                                    ${distanceInfoHtml}
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px;">
                                        <button class="infowindow-btn" id="set-origin-btn">${uiStrings[currentLang].setAsOrigin}</button>
                                        <button class="infowindow-btn" id="${setDestButtonId}">${setDestButtonText}</button>
                                        <button class="infowindow-btn" id="set-home-btn" style="background-color: #27ae60;">${uiStrings[currentLang].setAsHome}</button>
                                    </div>
                                </div>
                            `;
                            infoWindow.setContent(content);
                            infoWindow.setPosition(e.latLng);
                            infoWindow.open(map);

                            // ストリートビューの位置をクリックした場所に更新
                            panorama.setPosition(place.geometry.location);
                        }
                    });
                }
            });

            // InfoWindow内のボタンにイベントリスナーを設定
            infoWindow.addListener('domready', () => {
                document.getElementById('set-origin-btn')?.addEventListener('click', () => {
                    if (selectedPlace && selectedPlace.geometry && selectedPlace.geometry.location) {
                        // POIクリック時は、まず場所の名前(place.name)を優先して使う
                        // これにより「東京駅」のような短い名前が表示される
                        const displayName = selectedPlace.name || selectedPlace.formatted_address;
                        if (displayName) {
                            originInput.value = displayName;
                        } else {
                            // 名前がない場合は逆ジオコーディングで住所を取得
                            setOriginToGeocodedLocation(selectedPlace.geometry.location);
                        }

                        originLatLng = selectedPlace.geometry.location;
                        jumpToPlace(selectedPlace);
                        infoWindow.close();
                    }
                });
                document.getElementById('set-dest-btn')?.addEventListener('click', () => {
                    if (selectedPlace) {
                        destinationInput.value = selectedPlace.name || selectedPlace.formatted_address;
                        destinationLatLng = selectedPlace.geometry.location;
                        infoWindow.close();
                    }
                });
                document.getElementById('set-dest-and-search-btn')?.addEventListener('click', () => {
                    if (selectedPlace) {
                        destinationInput.value = selectedPlace.name || selectedPlace.formatted_address;
                        destinationLatLng = selectedPlace.geometry.location;
                        infoWindow.close();
                        // 即座に経路検索を実行
                        calculateAndDisplayRoute();
                    }
                });
                document.getElementById('set-home-btn')?.addEventListener('click', () => {
                    if (selectedPlace && selectedPlace.geometry && selectedPlace.geometry.location) {
                        const homeLocation = {
                            lat: selectedPlace.geometry.location.lat(),
                            lng: selectedPlace.geometry.location.lng()
                        };
                        // ホーム地点をlocalStorageに保存
                        localStorage.setItem('streetMoViewHomeLocation', JSON.stringify(homeLocation));
                        showMessage(uiStrings[currentLang].homeSet, false);
                        infoWindow.close();
                    }
                });
            });

            // 出発地・目的地のオートコンプリート設定
            const autocompleteOptions = {
                fields: ["geometry", "name", "formatted_address"],
                types: ["geocode", "establishment"],
            };
            originAutocomplete = new google.maps.places.Autocomplete(originInput, autocompleteOptions);
            destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput, autocompleteOptions);

            originAutocomplete.addListener('place_changed', () => {
                originLatLng = originAutocomplete.getPlace()?.geometry?.location || null;
            });
            destinationAutocomplete.addListener('place_changed', () => {
                destinationLatLng = destinationAutocomplete.getPlace()?.geometry?.location || null;
            });

            const elevationChartCanvas = document.getElementById('elevation-chart');
            elevationChartCanvas.addEventListener('click', handleChartClick);

            routeButton.addEventListener('click', calculateAndDisplayRoute);
            toggleTourButton.addEventListener('click', toggleTour);
            bleConnectButton.addEventListener('click', connectToBleDevice);
            boostButton.addEventListener('click', () => { /* イベントリスナーは既に設定済み */ });
            logToggleButton.addEventListener('click', toggleLogging);
            hrConnectButton.addEventListener('click', connectToHrDevice);

            // 言語スイッチャーのイベントリスナー
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setLanguage(e.target.dataset.lang);
                });
            });

            // ストリートビューカバレッジのトグルスイッチ
            const svCoverageToggle = document.getElementById('sv-coverage-toggle');
            svCoverageToggle.addEventListener('change', (event) => {
                streetViewCoverageLayer.setMap(event.target.checked ? map : null);
            });

            // ユーザー投稿データ表示のトグルスイッチ
            const userContentToggle = document.getElementById('user-content-toggle');
            userContentToggle.addEventListener('change', (event) => {
                showUserContent = event.target.checked;
                // panoramaのsourceを更新して即時反映
                panorama.setOptions({ source: showUserContent ? google.maps.StreetViewSource.DEFAULT : google.maps.StreetViewSource.OUTDOOR });
            });

            // タブが再度表示されたときにWake Lockを再取得する
            document.addEventListener('visibilitychange', async () => {
                if (isTourRunning && document.visibilityState === 'visible') {
                    await requestWakeLock();
                }
            });

            // 手動での速度変更を検知
            speedInput.addEventListener('input', () => {
                const speed = parseFloat(speedInput.value);
                // 速度の変更はtourStepループ内で自動的に反映される
            });

            [originInput, destinationInput].forEach(input => {
                input.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        calculateAndDisplayRoute();
                    }
                });
            });

            // ユーザーが手動で入力した場合、保存されたLatLngをクリアする
            originInput.addEventListener('input', () => {
                originLatLng = null;
            });
            destinationInput.addEventListener('input', () => {
                destinationLatLng = null;
            });

            const splitter = document.getElementById('splitter');
            const mapDiv = document.getElementById('map');
            const streetViewDiv = document.getElementById('street-view');
            const splitContainer = document.getElementById('split-container');
            let isDragging = false;
            let startPos;
            let startSize;

            streetViewDiv.style.flexGrow = '0';
            mapDiv.style.flexGrow = '0';

            const initialRatio = 0.7;
            const isMobile = window.innerWidth <= 767;
            if (isMobile) {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetHeight * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetHeight * (1 - initialRatio)}px`;
            } else {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetWidth * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetWidth * (1 - initialRatio)}px`;
            }

            splitter.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
                document.body.style.cursor = isMobile ? 'row-resize' : 'col-resize';
                mapDiv.style.transition = 'none';
                streetViewDiv.style.transition = 'none';
                if (isMobile) {
                    startPos = e.clientY;
                    startSize = streetViewDiv.offsetHeight;
                } else {
                    startPos = e.clientX;
                    startSize = streetViewDiv.offsetWidth;
                }
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging) return;
                isDragging = false;
                document.body.style.cursor = 'default';
                mapDiv.style.transition = 'flex 0.3s ease';
                streetViewDiv.style.transition = 'flex 0.3s ease';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = splitContainer.getBoundingClientRect();
                const minSize = 100;
                let newSize;
                if (isMobile) {
                    const delta = e.clientY - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.height - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.height - newSize}px`;
                } else {
                    const delta = e.clientX - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.width - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.width - newSize}px`;
                }
            });
        }

        function loadMapsScript() {
            if (window.google && window.google.maps) {
                initMap();
                return;
            }

            // Google Maps APIキーが無効だった場合に呼び出されるコールバック
            window.gm_authFailure = function() {
                console.error("Google Maps API key authentication failed. Clearing the stored key.");
                // 保存されている無効なAPIキーを削除
                localStorage.removeItem('streetMoViewApiKey');
                // ページをリロードして、再度キー入力を促す
                location.reload();
            };

            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap&libraries=places,geometry`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        function disableApiDependentFeatures(disabled) {
            routeButton.disabled = disabled;
            loadGpxButton.disabled = disabled;
            // 他のAPI依存機能があればここに追加
        }

        let GOOGLE_MAPS_API_KEY = localStorage.getItem('streetMoViewApiKey');
        let initialLocation = { lat: 35.681236, lng: 139.767125 }; // デフォルト: 東京駅

        // APIキーを読み込む前に、まずlocalStorageからホーム位置を読み込んでおく
        // これにより、APIキー入力プロンプトが表示される前に地図の中心位置が決まる
        const savedHomeBeforeApi = localStorage.getItem('streetMoViewHomeLocation');
        if (savedHomeBeforeApi) {
            try {
                const homeCoords = JSON.parse(savedHomeBeforeApi);
                if (homeCoords && typeof homeCoords.lat === 'number' && typeof homeCoords.lng === 'number') {
                    initialLocation = homeCoords;
                }
            } catch (e) { /* パース失敗時はデフォルト値を使用 */ }
        }

        window.addEventListener('DOMContentLoaded', () => {
            fullscreenButton = document.getElementById('fullscreen-button');
            fullscreenButton.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButtonState);

            // 初期速度を設定
            speedInput.value = defaultSettings[currentTravelMode].speed;

            // --- 保存された設定を読み込む ---
            const savedVoiceEnabled = localStorage.getItem('isVoiceGuidanceEnabled');
            if (savedVoiceEnabled !== null) {
                isVoiceGuidanceEnabled = (savedVoiceEnabled === 'true');
            }
            voiceGuidanceToggle.checked = isVoiceGuidanceEnabled;

            const savedGeocodeInterval = localStorage.getItem('geocodeIntervalDistance');
            if (savedGeocodeInterval !== null) {
                geocodeIntervalDistance = parseInt(savedGeocodeInterval, 10);
            }
            geocodeIntervalInput.value = geocodeIntervalDistance;

            const savedThreshold = localStorage.getItem('autoBoostThreshold');
            if (savedThreshold !== null) {
                autoBoostThreshold = parseInt(savedThreshold, 10);
            }
            autoBoostThresholdInput.value = autoBoostThreshold;
            // ---------------------------------

            setLanguage(currentLang); // ★最初に言語を設定

            let GOOGLE_MAPS_API_KEY = localStorage.getItem('streetMoViewApiKey');

            if (!GOOGLE_MAPS_API_KEY) {
                const promptMessages = {
                    ja: 'このアプリケーションを利用するにはGoogle Maps APIキーが必要です。\nAPIキーを入力してください。キーはブラウザに保存され、外部には送信されません。',
                    en: 'A Google Maps API Key is required to use this application.\nPlease enter your API key. It will be stored in your browser and will not be sent externally.'
                };
                GOOGLE_MAPS_API_KEY = prompt(promptMessages[currentLang]);
                if (GOOGLE_MAPS_API_KEY && GOOGLE_MAPS_API_KEY.trim() !== '') {
                    localStorage.setItem('streetMoViewApiKey', GOOGLE_MAPS_API_KEY);
                    // キーを保存したらリフレッシュしてAPIスクリプトを読み込ませる
                    location.reload();
                    return; // リフレッシュするので以降の処理は不要
                } else {
                    // キーが入力されなかった場合はブランクページに移動
                    //window.location.href = 'about:blank';
                    // 代わりにメッセージを表示する改善案
                    document.body.innerHTML = '<h1>Google Maps API Key is required. Please reload and enter your key.</h1>';
                    return;
                }
            }
            
            if (GOOGLE_MAPS_API_KEY) {
                loadMapsScript();
            } else {
                // このケースはlocalStorageにキーがなく、promptもキャンセルされた場合に到達する
                window.location.href = 'about:blank';
            }
        });
    </script>
</body>
</html>
