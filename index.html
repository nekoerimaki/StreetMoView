<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 100vw;
            overflow: hidden;
        }

        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            padding: 8px 15px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .dropdown-container {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: white;
            min-width: 300px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            padding: 10px;
            border-radius: 8px;
            flex-direction: column;
            gap: 10px;
        }

        #settings-dropdown {
            right: 0; /* 右端に表示 */
            left: auto;
            min-width: 250px; /* 経路設定と幅を合わせる */
        }

        .dropdown-content.show {
            display: flex;
        }

        /* マップ左下のコントロールコンテナ */
        #map-controls-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 5px;
            border-radius: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            margin: 0px 10px;
        }
        .item {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            align-items: center;
        }
        #map-controls-container label {
            font-size: 13px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
        }

        /* トグルスイッチのスタイル */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3; /* 青色 */
        }
        input:checked + .slider:before {
            transform: translateX(14px);
        }

        .dropdown-content input[type="text"] {
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .dropdown-content button {
            width: 100%;
        }

        .input-group, .action-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-groups {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header-links {
            display: flex;
            align-items: center;
            gap: 15px;
            white-space: nowrap;
        }

        #speed-input, #interval-input {
            width: 60px;
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 15px;
            font-size: 0.9rem;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            white-space: nowrap;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #split-container {
            display: flex;
            flex-grow: 1;
            position: relative;
        }

        #map, #street-view {
            height: 100%;
            transition: flex 0.3s ease;
            position: relative;
        }

        #street-view {
            flex-grow: 0.7;
            flex-basis: 70%;
        }

        #map {
            flex-grow: 0.3;
            flex-basis: 30%;
        }

        .splitter {
            width: 8px;
            background-color: #bdc3c7;
            cursor: col-resize;
            z-index: 2;
        }

        #message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #e74c3c;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .mode-switcher {
            display: flex;
            border: 2px solid #3498db;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-switcher button {
            background-color: white;
            color: #3498db;
            padding: 8px 12px;
            border-radius: 0;
            box-shadow: none;
            transition: background-color 0.2s, color 0.2s;
        }

        .mode-switcher button.active {
            background-color: #3498db;
            color: white;
        }

        #info-display {
            background-color: transparent; /* 背景を完全に透明にする */
            position: relative; /* z-indexを有効にするため */
            z-index: 1; /* グラフより手前に表示 */
            color: #333; /* デフォルトの文字色を濃いグレーに */
            padding: 5px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px 15px; /* 横のgapを少し詰める */
            justify-content: flex-start; /* 左詰めにする */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1; /* 利用可能なスペースを均等に埋める */
        }
        .info-label {
            font-weight: bold;
            color: #7f8c8d; /* ラベルの文字色を少し薄いグレーに */
        }
        .info-value {
            font-size: 1.1rem;
            color: white; /* 値の文字色を白に */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5); /* 影をつけて読みやすくする */
        }

        #lang-switcher {
            display: flex;
            gap: 5px;
        }
        .lang-btn {
            padding: 5px 10px;
            font-size: 0.8rem;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: none;
            transform: none;
        }
        .lang-btn:hover {
            background-color: #bdc3c7;
            transform: none;
        }
        .lang-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .header-links a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .header-links a:hover {
            text-decoration: underline;
        }
        #fullscreen-button {
            background-color: transparent;
            border: none;
            box-shadow: none;
            width: 40px;
            height: 40px;
            padding: 0px;
            cursor: pointer;
            color: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #fullscreen-button:hover {
            background-color: #ecf0f1;
            transform: none;
        }

        .infowindow-btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: none;
            transform: none;
        }
        .infowow-btn:hover {
            background-color: #2980b9;
        }

        #boost-button {
            display: none; /* Initially hidden */
            background-color: transparent;
            border: 1px solid #bdc3c7;
            color: #bdc3c7;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            box-shadow: none;
            transform: none;
            align-items: center;
            justify-content: center;
            transition: color 0.2s, background-color 0.2s, border-color 0.2s;
        }
        #boost-button.active {
            background-color: #f1c40f;
            color: white;
            border-color: #f1c40f;
        }

        #info-display #boost-button {
            display: none; /* Initially hidden */
            background-color: transparent;
            border: 1px solid #bdc3c7;
            color: #bdc3c7;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            box-shadow: none;
            transform: none;
            align-self: center; /* Vertically center in the flex container */
            margin: 0 10px;
            flex-grow: 0; /* この要素は伸縮させない */
        }
        #info-display #boost-button svg {
            width: 60%; /* ボタンの幅に対する割合でサイズを指定 */
            height: 100%;
        }
        #info-display #boost-button.active {
            background-color: #f1c40f;
            color: white;
            border-color: #f1c40f;
        }

        /* Google Places Autocomplete suggestions z-index fix */
        .pac-container {
            z-index: 2001; /* Must be higher than .modal-overlay's z-index */
        }


        /* Responsive design for mobile */
        @media (max-width: 767px) {
            .controls-area {
                padding: 10px;
                flex-direction: column;
                align-items: flex-start;
            }

            .input-group, .action-group {
                flex-direction: column;
                gap: 5px;
                width: 100%;
            }

            .input-group label {
                width: 100%;
                text-align: left;
            }

            #origin-input, #destination-input, #speed-input, #interval-input, button {
                width: 100%;
            }
            .dropdown-content {
                min-width: auto;
                width: 100%;
            }

            #split-container {
                flex-direction: column;
            }

            #street-view, #map {
                flex-basis: auto;
                height: 50%;
                width: 100%;
            }

            .splitter {
                height: 8px;
                width: 100%;
                cursor: row-resize;
            }
            .mode-switcher {
                width: 100%;
            }

            #info-display {
                gap: 10px;
                padding: 10px 0px;
                justify-content: center;
            }
            .info-item {
                flex-basis: 45%;
                align-items: flex-start;
            }
        }

        #elevation-chart-container {
            width: 100%;
            height: 80px; /* 少し高さを詰める */
            background-color: #2c3e50; /* 背景色を戻す */
            padding: 5px 5px;
            box-sizing: border-box;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none; /* Initially hidden */
            margin-top: -30px; /* info-displayと30pxオーバーラップさせる */
        }
        
        #direction-settings-dropdown {
            padding: 5px;
        }
        #direction-switcher {
            border: none;
        }

        #elevation-chart {
            width: 100%;
            height: 100%;
            cursor: not-allowed; /* Initially not clickable */
        }

        /* ストリートビュー左下の表示方向コントロール（試作） */
        #direction-control-overlay {
            position: absolute;
            bottom: 10px;
            left: 50%;
            z-index: 5; /* ストリートビューのUIより手前に表示 */
            transform: translateX(-50%); /* 要素の幅の半分だけ左にずらして中央揃え */
            background-color: rgba(255, 255, 255, 0.85);
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 2px;
        }

        #direction-control-overlay button {
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
            box-shadow: none;
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        #direction-control-overlay button.active {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }

        /* オートブースト設定 */
        #auto-boost-settings {
            display: none; /* 初期状態では非表示 */
        }
        #auto-boost-settings-dropdown {
            min-width: 180px;
            padding: 15px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .settings-item label {
            white-space: nowrap;
        }
        .settings-item select {
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        .settings-item label {
            flex-grow: 1; /* ラベルが利用可能なスペースを埋める */
        }
        .settings-item select {
            flex-grow: 1; /* 残りのスペースをすべて使う */
        }
        .settings-item switch {
            width: 70px; /* 固定幅を指定 */
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        .settings-item input[type="number"] {
            width: 70px; /* 固定幅を指定 */
            flex-shrink: 0; /* 幅が縮まないようにする */
        }
        #settings-dropdown #lang-switcher {
            justify-content: center;
            margin-bottom: 10px;
        }
        #settings-dropdown input[type="number"], #settings-dropdown select {
            padding: 8px;
            font-size: 0.9rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div class="controls-area">
            <div class="control-groups">
                <div class="dropdown-container">
                    <button id="route-settings-button" data-i18n="routeSettings">経路設定</button>
                    <div class="dropdown-content" id="route-settings-dropdown">                        
                        <input type="text" id="origin-input" placeholder="出発地: 例. 東京駅" data-i18n-placeholder="originPlaceholder">
                        <input type="text" id="destination-input" placeholder="目的地: 例. 渋谷スクランブル交差点" data-i18n-placeholder="destinationPlaceholder">
                        <div class="mode-switcher">
                            <button id="driving-mode-btn" data-mode="DRIVING" data-i18n="driving">自動車</button>                            
                            <button id="bicycling-mode-btn" data-mode="BICYCLING" class="active" data-i18n="bicycling">自転車</button>
                            <button id="bicycling-road-mode-btn" data-mode="BICYCLING_ROAD" data-i18n="bicycling_road">自転車(車道)</button>
                            <button id="walking-mode-btn" data-mode="WALKING" data-i18n="walking">徒歩</button>                            
                        </div>
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                            <label for="interval-input" data-i18n="interpolationInterval" style="white-space: nowrap;">補間間隔 (m):</label>
                            <input type="number" id="interval-input" value="5" min="1" max="100">
                        </div>
                        <button id="route-button" data-i18n="searchRoute">経路を検索</button>
                        <button id="load-gpx-button" data-i18n="loadGpx">GPXを読み込む</button>
                    </div>
                    <input type="file" id="gpx-file-input" accept=".gpx" style="display: none;">
                </div>
                <div class="action-group">
                    <label for="speed-input" data-i18n="speed">速度 (km/時):</label>
                    <input type="number" id="speed-input" value="0" min="1" max="60">
                    <button id="toggle-tour-button" disabled data-i18n="startTour">ツアー開始</button>
                    <button id="ble-connect-button" data-i18n="connectPower">パワーソースに接続</button>
                    <button id="hr-connect-button" data-i18n="connectHr">心拍計に接続</button>
                    <button id="log-toggle-button" data-i18n="startLog">ログ開始</button>
                </div>
            </div>
            <div class="header-links">
                <div class="dropdown-container" id="settings-container">
                    <button id="settings-button" title="設定" data-i18n="settings">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                            <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>
                        </svg>
                        <span data-i18n="settings">設定</span>
                    </button>
                    <div class="dropdown-content" id="settings-dropdown">
                        <div id="lang-switcher">
                            <button data-lang="ja" class="lang-btn active">日本語</button>
                            <button data-lang="en" class="lang-btn">English</button>
                        </div>
                        <div class="settings-item">
                            <label for="voice-guidance-toggle" data-i18n="voiceGuidance">音声ガイダンス</label>
                            <div>
                            <label class="switch">
                                <input type="checkbox" id="voice-guidance-toggle">
                                <span class="slider"></span>
                            </label>
                            </div>
                        </div>
                        <div class="settings-item">
                            <label for="voice-select" data-i18n="voiceSelect">声色</label>
                            <select id="voice-select" disabled></select>
                        </div>
                        <div class="settings-item">
                            <label for="geocode-interval-input" data-i18n="geocodeInterval">住所確認の間隔 (m)</label>
                            <input type="number" id="geocode-interval-input" min="100" max="5000" step="100">
                        </div>
                        <div class="settings-item">
                            <label for="auto-boost-threshold" data-i18n="autoBoostThresholdLabel">自動ブースト勾配 (%)</label>
                            <input type="number" id="auto-boost-threshold" min="0" max="50" step="1">
                        </div>
                    </div>
                </div>
                <button id="fullscreen-button" title="フルスクリーン">
                    <svg class="icon-fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="28" height="28">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    <svg class="icon-exit-fullscreen" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="28" height="28" style="display: none;">
                        <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div id="info-display">
            <div class="info-item">
                <span class="info-label" data-i18n="totalDist">経路全体</span>
                <span class="info-value" id="total-dist">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="currentPos">現在位置</span>
                <span class="info-value" id="current-pos">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="distTraveled">移動距離</span>
                <span class="info-value" id="dist-traveled">0.00 km</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeElapsed">移動時間</span>
                <span class="info-value" id="time-elapsed">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="actualSpeed">移動速度</span>
                <span class="info-value" id="actual-speed">0.0 km/h</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="timeRemaining">残り時間</span>
                <span class="info-value" id="time-remaining">00:00:00</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="elevation">標高</span>
                <span class="info-value" id="elevation">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="gradient">勾配</span>
                <span class="info-value" id="gradient">N/A</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="power">パワー</span>
                <span class="info-value" id="power-display">0 W</span>
            </div>
            <button id="boost-button" title="ブースト">
                <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641z"/>
                </svg>
            </button>
            <div class="info-item">
                <span class="info-label" data-i18n="cadence">ケイデンス</span>
                <span class="info-value" id="cadence-display">0 rpm</span>
            </div>
            <div class="info-item">
                <span class="info-label" data-i18n="heartRate">心拍数</span>
                <span class="info-value" id="hr-display">0 bpm</span>
            </div>
        </div>
        <div id="elevation-chart-container">
            <canvas id="elevation-chart"></canvas>
        </div>
        <div id="split-container">
            <div id="street-view">
                <!-- ストリートビュー左下の表示方向コントロール（試作） -->
                <div id="direction-control-overlay" class="mode-switcher">
                    <button data-angle="-90" data-i18n="left90">左90°</button>
                    <button data-angle="-45" data-i18n="left45">左45°</button>
                    <button data-angle="0" data-i18n="front" class="active">正面</button>
                    <button data-angle="45" data-i18n="right45">右45°</button>
                    <button data-angle="90" data-i18n="right90">右90°</button>
                </div>
            </div>
            <div class="splitter" id="splitter"></div>
            <div id="map"></div>
        </div>
        <!-- マップ左下に配置するコントロール -->
        <div id="map-controls-container" style="display: none;">
                <div class="item">
                    <label for="tilt-view-toggle" data-i18n="tiltView" id="tilt-view-label">チルト表示</label>
                    <label class="switch">
                        <input type="checkbox" id="tilt-view-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="item">
                    <label for="sv-coverage-toggle" data-i18n="svCoverage">SV道路表示</label>
                    <label class="switch">
                        <input type="checkbox" id="sv-coverage-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="item">
                    <label for="user-content-toggle" data-i18n="userContent">ユーザー投稿</label>
                    <label class="switch">
                        <input type="checkbox" id="user-content-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
        </div>
    </div>
    <div id="message-box"></div>

    <script type="module">
        // TTSエンジンクラスをモジュールからインポート
        import { VVoxEngine } from './script/VVoxEngine.js';
        import { VoiceVoxWebApi } from './script/VoiceVoxWeb.js';


        const uiStrings = {
            ja: {
                routeSettings: '経路設定',
                originPlaceholder: '出発地: 例. 東京駅',
                destinationPlaceholder: '目的地: 例. 渋谷スクランブル交差点',
                driving: '自動車',                
                bicycling_road: '自転車(車道)',
                bicycling: '自転車',
                walking: '徒歩',
                interpolationInterval: '補間間隔 (m):',
                searchRoute: '経路を検索',
                loadGpx: 'GPXを読み込む',
                speed: '速度 (km/時):',
                userContent: 'ユーザー投稿',
                startTour: 'ツアー開始',
                stopTour: 'ツアー停止',
                connectPower: 'パワーソースに接続',
                connectHr: '心拍計に接続',
                disconnect: '接続解除',
                startLog: 'ログ開始',
                stopLog: 'ログ終了',
                distTraveled: '移動距離',
                totalDist: '経路全体',
                currentPos: '現在位置',
                timeElapsed: '移動時間',
                actualSpeed: '移動速度',
                timeRemaining: '残り時間',
                elevation: '標高',
                gradient: '勾配',
                power: 'パワー',
                cadence: 'ケイデンス',
                heartRate: '心拍数',
                directionSettings: '表示方向',
                left90: '左90°',
                left45: '左45°',
                front: '正面',
                right45: '右45°',
                right90: '右90°',
                startPoint: '出発地',
                endPoint: '目的地',
                currentLocation: '現在地',
                // messages
                noStreetView: 'この経路のストリートビューデータが見つかりませんでした。',
                routeFound: '経路が見つかりました！巡回を開始できます。',
                elevationProcessed: '経路の標高データを補正しました。',
                elevationError: '標高データの取得または補正に失敗しました。',
                originDestRequired: '出発地と目的地を入力してください。',
                invalidInterval: '有効な補間間隔を入力してください。',
                routeSearchFailed: '経路検索に失敗しました: ',
                routeNotFound: '経路が見つかりませんでした。場所を確認してください。',
                gpxNoTrackpoints: 'GPXファイルにトラックポイントが見つかりませんでした。',
                gpxNoCoordinates: 'GPXファイルから有効な座標を抽出できませんでした。',
                gpxParseError: 'GPXファイルの解析中にエラーが発生しました。',
                destinationReached: '目的地に到達しました。',
                noRouteForTour: 'まず経路を検索するかGPXファイルを読み込んでください。',
                invalidSpeed: '有効な速度を入力してください。',
                searchingDevice: 'デバイスを検索中です...',
                connectingDevice: 'デバイスに接続中です...',
                gattConnected: 'GATTサーバーに接続しました。',
                ftmsConnected: 'FTMSデバイスに接続しました。',
                btConnectionFailed: 'Bluetooth接続に失敗しました:',
                btConnectionError: 'Bluetooth接続エラー: ',
                deviceDisconnected: 'デバイスから切断しました。',
                searchingHr: '心拍計を検索中です...',
                connectingHr: '心拍計に接続中です...',
                hrConnected: '心拍計に接続しました。',
                hrConnectionFailed: '心拍計の接続に失敗しました:',
                hrConnectionError: '心拍計接続エラー: ',
                hrDisconnected: '心拍計から切断しました。',
                logStarted: 'ログ記録を開始しました。',
                logStopped: 'ログ記録を終了しました。',
                confirmSaveTcx: '記録したアクティビティをTCXファイルとして保存しますか？',
                powerZeroStop: '速度が低下したためツアーを停止しました。',
                powerDetectedStart: 'パワーを検出。ツアーを開始します。',
                jumpDisabledDuringTour: 'ツアー中はジャンプできません。',
                fullscreen: 'フルスクリーン',
                exitFullscreen: 'フルスクリーン解除',
                fullscreenError: 'フルスクリーンモードへの移行に失敗しました: ',
                setAsOrigin: 'ここへ移動',
                setAsDestinationAndSearch: 'ここへの経路を検索',
                setAsDestination: '目的地に設定',
                setAsHome: 'ホームに設定',
                arrivedAt: '{location} に到着しました。おつかれさまでした。',
                homeSet: 'ホーム地点を設定しました。次回起動時にこの場所から開始します。',
                boost: 'ブースト',
                municipalityGuidance: '{municipality} を移動中です。',
                settings: '設定',
                voiceGuidance: '地名アナウンス',
                departingFrom: '{location} から出発します。',
                voiceSelect: '声色',
                geocodeInterval: '地名確認の間隔 (m)',
                autoBoostSettings: '自動ブースト',
                autoBoostThresholdLabel: '自動ブースト勾配 (%)',
                boostOn: 'ブーストON',
                routeSettingsDisabled: 'ツアー中またはログ記録中は経路設定を変更できません。',
                searchForPlace: '場所を検索',
                svCoverage: 'SV道路表示',
                //headingUp: '進行方向を上に',
                tiltView: 'チルト表示',
            },
            en: {
                routeSettings: 'Route Settings',
                originPlaceholder: 'Origin: e.g., Tokyo Station',
                destinationPlaceholder: 'Destination: e.g., Shibuya Crossing',
                driving: 'Driving',
                bicycling_road: 'Bicycling (Road)',
                bicycling: 'Bicycling',
                walking: 'Walking',
                interpolationInterval: 'Interval (m):',
                searchRoute: 'Search Route',
                loadGpx: 'Load GPX',
                userContent: 'User Content',
                speed: 'Speed (km/h):',
                startTour: 'Start Tour',
                stopTour: 'Stop Tour',
                connectPower: 'Connect P.S.',
                connectHr: 'Connect H.R.',
                disconnect: 'Disconnect',
                startLog: 'Start Logging',
                stopLog: 'Stop Logging',
                distTraveled: 'Distance Traveled',
                totalDist: 'Total Distance',
                currentPos: 'Current Position',
                timeElapsed: 'Time Elapsed',
                actualSpeed: 'Actual Speed',
                timeRemaining: 'Time Remaining',
                elevation: 'Elevation',
                gradient: 'Gradient',
                power: 'Power',
                cadence: 'Cadence',
                heartRate: 'Heart Rate',
                directionSettings: 'View Dir',
                left90: 'Left 90°',
                left45: 'Left 45°',
                front: 'Front',
                right45: 'Right 45°',
                right90: 'Right 90°',
                startPoint: 'Start Point',
                endPoint: 'End Point',
                currentLocation: 'Current Location',
                // messages
                noStreetView: 'Street View data could not be found for this route.',
                routeFound: 'Route found! You can start the tour.',
                elevationProcessed: 'Route elevation data has been processed.',
                elevationError: 'Failed to get or process elevation data.',
                originDestRequired: 'Please enter an origin and destination.',
                invalidInterval: 'Please enter a valid interpolation interval.',
                routeSearchFailed: 'Directions request failed due to: ',
                routeNotFound: 'Route not found. Please check the locations.',
                gpxNoTrackpoints: 'No trackpoints found in the GPX file.',
                gpxNoCoordinates: 'Could not extract valid coordinates from the GPX file.',
                gpxParseError: 'An error occurred while parsing the GPX file.',
                destinationReached: 'You have reached your destination.',
                noRouteForTour: 'Please search for a route or load a GPX file first.',
                invalidSpeed: 'Please enter a valid speed.',
                searchingDevice: 'Searching for device...',
                connectingDevice: 'Connecting to device...',
                gattConnected: 'Connected to GATT Server.',
                ftmsConnected: 'Connected to FTMS device.',
                btConnectionFailed: 'Bluetooth connection failed:',
                btConnectionError: 'Bluetooth connection error: ',
                deviceDisconnected: 'Disconnected from device.',
                searchingHr: 'Searching for heart rate monitor...',
                connectingHr: 'Connecting to heart rate monitor...',
                hrConnected: 'Connected to heart rate monitor.',
                hrConnectionFailed: 'Failed to connect to heart rate monitor:',
                hrConnectionError: 'Heart rate monitor connection error: ',
                hrDisconnected: 'Disconnected from heart rate monitor.',
                logStarted: 'Log recording started.',
                logStopped: 'Log recording stopped.',
                confirmSaveTcx: 'Do you want to save the recorded activity as a TCX file?',
                powerZeroStop: 'Tour stopped due to low speed.',
                powerDetectedStart: 'Power detected. Starting the tour.',
                jumpDisabledDuringTour: 'Cannot jump during an active tour.',
                fullscreen: 'Fullscreen',
                exitFullscreen: 'Jump Here',
                fullscreenError: 'Error attempting to enable full-screen mode: ',
                setAsOrigin: 'Set as Origin',
                setAsDestinationAndSearch: 'Route to here',
                setAsDestination: 'Set as Destination',
                setAsHome: 'Set as Home',
                arrivedAt: 'Arrived at {location}. Well done!',
                homeSet: 'Home location set. The app will start here next time.',
                boost: 'Boost',
                municipalityGuidance: 'Now passing through {municipality}.',
                settings: 'Settings',
                voiceGuidance: 'Location Announcement',
                departingFrom: 'Departing from {location}.',
                voiceSelect: 'Voice',
                geocodeInterval: 'Location Check Interval (m)',
                autoBoostSettings: 'Auto Boost',
                autoBoostThresholdLabel: 'Auto Boost Gradient',
                boostOn: 'Boost ON',
                routeSettingsDisabled: 'Cannot change route settings during a tour or while logging.',
                searchForPlace: 'Search for a Place',
                svCoverage: 'SV Coverage',
                //headingUp: 'Heading Up',
                tiltView: 'Tilt View',
            }
        };
        let currentLang = 'ja';

        /**
         * メッセージボックスにメッセージを表示します。
         * @param {string} message - 表示するメッセージ
         * @param {boolean} isError - エラーメッセージかどうか
         */
        function showMessage(message, isError = true) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.style.backgroundColor = isError ? '#e74c3c' : '#27ae60';
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.opacity = '1';
            }, 10);
            setTimeout(() => {
                messageBox.style.opacity = '0';
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 500);
            }, 3000);
        }

        /**
         * グラフの横軸に最適な目盛り間隔を計算します。
         * @param {number} totalDistance - 経路の総距離 (m)
         * @returns {number} - 目盛り間隔 (m)
         */
        function getNiceTickInterval(totalDistance) {
            if (totalDistance <= 0) return 500; // デフォルト値

            const targetTicks = 8; // 目指す目盛りの数
            const rawInterval = totalDistance / targetTicks;
            const power = Math.pow(10, Math.floor(Math.log10(rawInterval)));
            const normalizedInterval = rawInterval / power;

            if (normalizedInterval < 1.5) {
                return Math.max(1 * power, 10);
            } else if (normalizedInterval < 3) {
                return Math.max(2 * power, 10);
            } else if (normalizedInterval < 7) {
                return Math.max(5 * power, 10);
            }
            return Math.max(10 * power, 10);
        }

        /**
         * 経路全体の標高グラフを描画します。
         * @param {number} currentDistance - 現在の移動距離 (m)
         */
        function drawElevationChart(currentDistance = 0) {
            // グラフ描画に必要なデータが揃っているか確認
            const container = document.getElementById('elevation-chart-container');
            if (routeElevations.length < 2) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';

            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');

            // 高DPIディスプレイに対応
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            ctx.clearRect(0, 0, width, height);

            // 標高データの範囲を計算
            const minElev = Math.min(...routeElevations);
            const maxElev = Math.max(...routeElevations);
            const elevRange = maxElev - minElev;

            const padding = { top: 10, bottom: 20, left: 40, right: 40 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // 座標計算用のヘルパー関数
            const getX = (dist) => padding.left + (dist / totalDistance) * chartWidth;
            const getElevY = (elev) => padding.top + chartHeight - ((elev - minElev) / (elevRange || 1)) * chartHeight;

            // --- グラフの描画 ---

            // 2. 標高グラフ（エリア）
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(52, 152, 219, 0.3)');
            gradient.addColorStop(1, 'rgba(44, 62, 80, 0.1)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.lineTo(getX(totalDistance), height - padding.bottom);
            ctx.lineTo(getX(0), height - padding.bottom);
            ctx.closePath();
            ctx.fill();

            // 4. 標高グラフ（線）
            ctx.beginPath();
            ctx.moveTo(getX(0), getElevY(routeElevations[0]));
            for (let i = 1; i < routeElevations.length; i++) {
                ctx.lineTo(getX(cumulativeDistances[i]), getElevY(routeElevations[i]));
            }
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 5. 横軸の目盛りとラベルを描画
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(189, 195, 199, 0.2)'; // #bdc3c7 with alpha
            ctx.lineWidth = 1;
            ctx.font = '9px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#bdc3c7';

            const tickInterval = getNiceTickInterval(totalDistance);
            for (let dist = tickInterval; dist < totalDistance; dist += tickInterval) {
                const x = getX(dist);
                ctx.moveTo(x, height - padding.bottom);
                ctx.lineTo(x, height - padding.bottom + 4); // 4pxの短い線

                const distKm = (dist / 1000);
                const precision = Math.max(0, -Math.floor(Math.log10(tickInterval / 1000)));
                const label = distKm.toFixed(precision);
                ctx.fillText(label, x, height - padding.bottom + 15);
            }
            ctx.stroke();

            // 6. 軸ラベルの描画
            ctx.fillStyle = '#bdc3c7';
            ctx.font = '10px Inter';
            // 左側：標高
            ctx.textAlign = 'right';
            ctx.fillText(`${maxElev.toFixed(0)} m`, padding.left - 5, padding.top + 5);
            ctx.fillText(`${minElev.toFixed(0)} m`, padding.left - 5, height - padding.bottom);

            // 7. 現在地マーカー
            if (currentDistance > 0 && currentDistance < totalDistance) {
                const markerX = getX(currentDistance);
                const markerY = getElevY(routeElevations[currentPointIndex]);
                ctx.beginPath();
                ctx.moveTo(markerX, padding.top);
                ctx.lineTo(markerX, height - padding.bottom);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(markerX, markerY, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }


        /**
         * 標高データの急激な変化を平滑化します。
         * 一定間隔でサンプリングし、2点間の勾配がしきい値を超える場合、次の点の標高を現在の点の標高に合わせます。
         * @param {Array<Object>} pointsData - 'distance'と'elevation'プロパティを持つオブジェクトの配列
         * @param {number} [samplingInterval=50] - 標高をチェックする間隔 (m)
         * @param {number} [maxGradient=15] - 許容される最大の勾配 (%)
         * @returns {Array<Object>} - 補正された標高データを持つ新しい配列
         */
        function smoothElevationsByGradient(pointsData, samplingInterval = 50, maxGradient = 20) {
            if (pointsData.length < 2) {
                return pointsData;
            }

            const correctedPoints = JSON.parse(JSON.stringify(pointsData)); // 元のデータを変更しないようにディープコピー

            for (let i = 0; i < correctedPoints.length - 1; i++) {
                const currentPoint = correctedPoints[i];
                const nextPoint = correctedPoints[i + 1];

                const distanceDiff = nextPoint.distance - currentPoint.distance;
                if (distanceDiff <= 0) continue; // 距離が増えていない場合はスキップ

                const elevationDiff = nextPoint.elevation - currentPoint.elevation;
                const gradient = (elevationDiff / distanceDiff) * 100;
                if (gradient > maxGradient) {
                    // 勾配がしきい値を超えたら、次のポイントの標高を現在のポイントに合わせる
                    correctedPoints[i + 1].elevation = currentPoint.elevation;
                }
                else if (i < (correctedPoints.length - 2)) {
                // 次と、次の次のポイントとの勾配が大きな下り勾配になるときも次のポイントの標高を現在のポイントに合わせる
                // →トンネル出口のスパイクをなくす為
                    const nextPoint2 = correctedPoints[i + 2];
                    const distanceDiff2 = nextPoint2.distance - nextPoint.distance;
                    const elevationDiff2 = nextPoint2.elevation - nextPoint.elevation;
                    const gradient2 = (elevationDiff2 / distanceDiff2) * 100;
                    if (gradient2 < -maxGradient) {
                        correctedPoints[i + 1].elevation = currentPoint.elevation;
                    }
                    else if (gradient > 10 && gradient2 < -10) {
                        correctedPoints[i + 1].elevation = currentPoint.elevation;
                    }
                }

            }
            return correctedPoints;
        }

        /**
         * 移動平均法を用いて標高データを平滑化します。
         * @param {Array<Object>} pointsData - 'elevation'プロパティを持つオブジェクトの配列
         * @param {number} windowSize - 平滑化のウィンドウサイズ（奇数を推奨）。大きいほど平滑化が強くなる。
         * @returns {Array<Object>} - 平滑化された標高データを持つ新しい配列
         */
        function applyMovingAverage(pointsData, windowSize) {
            if (pointsData.length < windowSize || windowSize <= 1) {
                return pointsData;
            }

            const smoothedPoints = JSON.parse(JSON.stringify(pointsData));
            const halfWindow = Math.floor(windowSize / 2);
            const elevations = pointsData.map(p => p.elevation);

            for (let i = 0; i < pointsData.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(pointsData.length, i + halfWindow + 1);
                const windowSlice = elevations.slice(start, end);
                
                const sum = windowSlice.reduce((acc, val) => acc + val, 0);
                const average = sum / windowSlice.length;
                
                smoothedPoints[i].elevation = average;
            }

            return smoothedPoints;
        }

        //異常勾配の始点、終点を探し範囲で標高を補正
        function correctAnomalyElevation(pointsData, maxGradient = 20) {
            if (pointsData.length < 3) {
                return pointsData;
            }

            const correctedPoints = JSON.parse(JSON.stringify(pointsData)); // 元のデータを変更しないようにディープコピー
            let startOfAnomaly = -1;
            const maxGradientAS = 3;
            let minGradientAS = maxGradientAS;
            let indexMinGradientAS = -1;
            for (let i = 0; i < correctedPoints.length - 2; i++) {
                const currentPoint = correctedPoints[i];
                const nextPoint = correctedPoints[i + 1];

                const distanceDiff = nextPoint.distance - currentPoint.distance;
                if (distanceDiff <= 0) continue; // 距離が増えていない場合はスキップ

                const elevationDiff = nextPoint.elevation - currentPoint.elevation;
                const gradient = (elevationDiff / distanceDiff) * 100;


                if (startOfAnomaly === -1) {
                    if (gradient > maxGradient) {
                        startOfAnomaly = i;
                        console.log(`startOfAnomaly: ${startOfAnomaly} gradient: ${gradient.toFixed(2)} elvation: ${currentPoint.elevation.toFixed(1)}}`);
                        minGradientAS = maxGradientAS;
                        indexMinGradientAS = -1;
                        continue;
                    } 
                }
                else {
                    const startAnomalyDistance = correctedPoints[startOfAnomaly].distance; //異常勾配の始点からの距離
                    if ((currentPoint.distance - startAnomalyDistance) > 3000) { // から4km以上離れたら
                        console.log(`cancel correct anomaly elevation by long distance`);
                        startOfAnomaly = -1; // 異常標高の終点の探索をあきらめる
                    }
                    else if (Math.abs(gradient) < maxGradient) { //現在の勾配は正常値なら
                        //現在の地点と異常勾配発生前の地点を結び
                        const startAnomalyElevation = correctedPoints[startOfAnomaly].elevation;
                        let evelationDiffAS = currentPoint.elevation - startAnomalyElevation;
                        let distanceDiffAS = currentPoint.distance - startAnomalyDistance;
                        let gradientAS = (evelationDiffAS / distanceDiffAS) * 100;
                        let doCorrect = false;
                        if (Math.abs(gradientAS) < maxGradientAS) { //その勾配も正常（長い距離をとる場合もあるので厳しい判断で）なら
                            if (gradientAS < minGradientAS) {
                                minGradientAS = gradientAS;
                                indexMinGradientAS = i;
                            }
                            else {
                                doCorrect = true;
                            }
                        }
                        else {
                            doCorrect = (indexMinGradientAS !== -1);
                        }
                        if (doCorrect) {
                            const endPoint = correctedPoints[indexMinGradientAS];
                            evelationDiffAS = endPoint.elevation - startAnomalyElevation;
                            distanceDiffAS = endPoint.distance - startAnomalyDistance;
                            gradientAS = (evelationDiffAS / distanceDiffAS) * 100;
                            //現地点までの標高を異常勾配の発生前の標高に補正
                            console.log(`correct anomaly elevation to index: ${indexMinGradientAS} gradient: ${gradient.toFixed(2)} elvation: ${endPoint.elevation}`);
                            console.log(`gradientAS: ${gradientAS.toFixed(2)}`);
                            for (let j = startOfAnomaly + 1; j < indexMinGradientAS; j++) {
                                const distFormAS = correctedPoints[j].distance - startAnomalyDistance;
                                correctedPoints[j].elevation = startAnomalyElevation + (distFormAS * gradientAS / 100);
                            }
                            startOfAnomaly = -1;
                        }
                    }
                }
            }
            return correctedPoints;
        }
        /**
         * 2つの緯度/経度座標間の距離をメートル単位で計算します。
         * @param {google.maps.LatLng} p1 - 最初の座標
         * @param {google.maps.LatLng} p2 - 2番目の座標
         * @returns {number} - 2点間の距離（メートル）
         */
        function getDistance(p1, p2) {
            const R = 6371e3;
            const φ1 = p1.lat() * Math.PI / 180;
            const φ2 = p2.lat() * Math.PI / 180;
            const Δφ = (p2.lat() - p1.lat()) * Math.PI / 180;
            const Δλ = (p2.lng() - p1.lng()) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        /**
         * 2つの緯度/経度座標間の距離をメートル単位で計算します。
         * @param {google.maps.LatLng} p1 - 最初の座標
         * @param {google.maps.LatLng} p2 - 2番目の座標
         * @returns {number} - 2点間の距離（メートル）
         */
        function getDistanceP(p1lat, p1lng, p2lat, p2lng) {
            const R = 6371e3;
            const φ1 = p1lat * Math.PI / 180;
            const φ2 = p2lat * Math.PI / 180;
            const Δφ = (p2lat - p1lat) * Math.PI / 180;
            const Δλ = (p2lng - p1lng) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        /**
         * 2点間で補間された緯度/経度座標を計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @param {number} fraction - 補間率 (0-1)
         * @returns {google.maps.LatLng} - 補間された座標
         */
        function interpolate(from, to, fraction) {
            const lat = from.lat() + (to.lat() - from.lat()) * fraction;
            const lng = from.lng() + (to.lng() - from.lng()) * fraction;
            return new google.maps.LatLng(lat, lng);
        }

        /**
         * 2点間の進行方向（ヘディング）を度単位で計算します。
         * @param {google.maps.LatLng} from - 開始点
         * @param {google.maps.LatLng} to - 終了点
         * @returns {number} - 進行方向（度）
         */
        function getHeading(from, to) {
            if (from.lat() === to.lat() && from.lng() === to.lng()) {
                return 0;
            }

            const lat1 = from.lat() * Math.PI / 180;
            const lon1 = from.lng() * Math.PI / 180;
            const lat2 = to.lat() * Math.PI / 180;
            const lon2 = to.lng() * Math.PI / 180;

            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let heading = Math.atan2(y, x) * 180 / Math.PI;

            heading = (heading + 360) % 360;
            return heading;
        }

        /**
         * 秒数を hh:mm:ss 形式にフォーマットします。
         * @param {number} seconds - 秒数
         * @returns {string} - フォーマットされた時間文字列
         */
        function formatTime(seconds) {
            const h = Math.floor(Math.abs(seconds) / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        /**
         * UI上の情報を更新します。
         */
        function updateInfoDisplay() {
            const totalDistanceKm = (totalDistance / 1000).toFixed(2);
            const currentPositionKm = (currentPositionDistance / 1000).toFixed(2);
            const distanceTraveledKm = (distanceTraveled / 1000).toFixed(2);
            const timeElapsed = totalTimeElapsed + (tourStartTime > 0 ? (Date.now() - tourStartTime) / 1000 : 0);

            const remainingDistance = Math.max(0, totalDistance - currentPositionDistance);
            const speedKmH = actualSpeedKmh;
            let timeRemaining = 0;
            if (speedKmH > 0) {
                timeRemaining = (remainingDistance / 1000) / speedKmH * 3600;
            }

            document.getElementById('current-pos').textContent = `${currentPositionKm} km`;
            document.getElementById('total-dist').textContent = `${totalDistanceKm} km`;
            document.getElementById('dist-traveled').textContent = `${distanceTraveledKm} km`;
            document.getElementById('time-elapsed').textContent = formatTime(timeElapsed);
            document.getElementById('time-remaining').textContent = formatTime(timeRemaining);
            document.getElementById('actual-speed').textContent = `${actualSpeedKmh.toFixed(1)} km/h`;

            if (routeElevations.length > 0 && currentPointIndex < routeElevations.length && cumulativeDistances.length > currentPointIndex) {
                const currentElevation = routeElevations[currentPointIndex];
                document.getElementById('elevation').textContent = `${currentElevation.toFixed(1)} m`;

            }
            document.getElementById('gradient').textContent = `${currentGradient.toFixed(1)} %`;

            // 勾配の値に応じて色を変更
            const gradientValueEl = document.getElementById('gradient');
            if (currentGradient >= 10) {
                gradientValueEl.style.color = '#e74c3c'; // 赤
            } else if (currentGradient >= 5) {
                gradientValueEl.style.color = '#f1c40f'; // 黄
            } else {
                gradientValueEl.style.color = ''; // デフォルトに戻す
            }

            // グラフを更新
            drawElevationChart(currentPositionDistance);
        }

        let map, panorama;
        let directionsService, directionsRenderer, elevationService, streetViewService, streetViewCoverageLayer;
        let routePoints = [];        
        let routeElevations = [];
        let gpxRoutePolyline = null;
        let cumulativeDistances = [];
        let sampledPointsData = [];
        let physicsIntervalId = null;
        let lastPhysicsUpdateTime = 0;
        let distanceSinceLastSvUpdate = 0;
        const STREETVIEW_UPDATE_DISTANCE = 20; // 20mごとにストリートビューを更新
        const PHYSICS_INTERVAL_MS = 500; // 500ms (2Hz)
        let currentLocationMarker;
        let isTourRunning = false;
        let currentPointIndex = 0;
        let startMarker, endMarker;
        let totalDistance = 0;
        let wakeLockSentinel = null;
        let currentPositionDistance = 0; // 経路上の現在位置を示す距離
        let distanceTraveled = 0; // 実際に走行した総距離
        let tourStartTime = 0;
        let directionOffset = 0;
        let totalTimeElapsed = 0;
        let currentGradient = 0;
        let isLogging = false;
        let logData = [];
        let logStartDistance = 0; // ログ開始時の走行距離
        let logStartTime = 0; // ログ開始時刻
        let currentPower = 0;
        let showUserContent = true; // ユーザー投稿データを表示するかのフラグ
        let currentCadence = 0;
        let currentHeartRate = 0;
        let isBoostActive = false;
        let isVectorMap = false; // ベクターマップが有効かどうかのフラグ
        let isTiltView = false; // チルト表示が有効かどうかのフラグ
        const BOOST_FACTOR = 1.5;
        let autoBoostThreshold = 10; // オートブーストのしきい値（%）
        let manualSpeedKmh = 0; // 手動入力の速度 (km/h)
        let actualSpeedKmh = 0; // 実際の移動速度 (km/h)

        let placesService, infoWindow, selectedPlace = null;
        let geocoder;
        let originLatLng = null, destinationLatLng = null;

        // 場所検索モーダル用
        // 出発地・目的地のオートコンプリート用
        let originAutocomplete, destinationAutocomplete;


        let currentMunicipality = ''; // 現在の市区町村名を保持
        let distanceSinceLastGeocode = 0; // 最後のジオコードからの距離
        let geocodeIntervalDistance = 1000; // 住所確認の間隔 (m)
        const PHYSICS_CONSTANTS = {
            RIDER_MASS: 70, // kg
            BIKE_MASS: 10, // kg
            get TOTAL_MASS() { return this.RIDER_MASS + this.BIKE_MASS; },
            CRR: 0.005, // 転がり抵抗係数 (asphalt)
            CDA: 0.3,   // 空気抵抗係数 * 前面投影面積 (m^2)
            RHO: 1.225, // 空気密度 (kg/m^3)
            G: 9.81,    // 重力加速度 (m/s^2)
            DRIVETRAIN_EFFICIENCY: 0.95, // 駆動系の効率
            MIN_SPEED_FOR_FORCE_CALC_MPS: 1.0, // 推進力計算時の最低速度 (m/s)
            STOPPING_SPEED_KMH: 3 // ツアーが自動停止する速度 (km/h)
        };

        let bleDevice = null;
        let ftmsCharacteristic = null;
        let hrDevice = null;
        let hrCharacteristic = null;
        const FTMS_SERVICE_UUID = 'fitness_machine';
        const INDOOR_BIKE_DATA_UUID = 'indoor_bike_data';

        const HR_SERVICE_UUID = 'heart_rate';
        const HR_MEASUREMENT_UUID = 'heart_rate_measurement';

        const routeSettingsButton = document.getElementById('route-settings-button');
        const routeSettingsDropdown = document.getElementById('route-settings-dropdown');
        const routeButton = document.getElementById('route-button');
        const loadGpxButton = document.getElementById('load-gpx-button');
        const gpxFileInput = document.getElementById('gpx-file-input');
        const toggleTourButton = document.getElementById('toggle-tour-button');
        const bleConnectButton = document.getElementById('ble-connect-button');
        const hrConnectButton = document.getElementById('hr-connect-button');
        const logToggleButton = document.getElementById('log-toggle-button');
        const boostButton = document.getElementById('boost-button');
        const settingsContainer = document.getElementById('settings-container');
        const settingsButton = document.getElementById('settings-button');
        const settingsDropdown = document.getElementById('settings-dropdown');
        const voiceGuidanceToggle = document.getElementById('voice-guidance-toggle');
        const voiceSelect = document.getElementById('voice-select');
        const geocodeIntervalInput = document.getElementById('geocode-interval-input');
        const autoBoostThresholdInput = document.getElementById('auto-boost-threshold');
        const originInput = document.getElementById('origin-input');
        const destinationInput = document.getElementById('destination-input');
        const intervalInput = document.getElementById('interval-input');
        let mapSearchInput = null;

        // 新しいオーバーレイのボタンのみを取得
        const directionButtons = document.querySelectorAll('#direction-control-overlay button');
        const speedInput = document.getElementById('speed-input');
        const travelModeButtons = document.querySelectorAll('.mode-switcher button');
        let fullscreenButton;        let currentTravelMode = 'BICYCLING';

        const defaultSettings = {
            'DRIVING': { speed: 50, interval: 10 },
            'BICYCLING': { speed: 20, interval: 5 }, // Google Maps標準の自転車モード
            'BICYCLING_ROAD': { speed: 20, interval: 5 }, // 高速を避けた自動車モード
            'WALKING': { speed: 5, interval: 3 }
        };

        /**
         * フルスクリーンモードを切り替えます。
         */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    showMessage(`${uiStrings[currentLang].fullscreenError}${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        /**
         * フルスクリーンボタンのテキストを現在の状態に合わせて更新します。
         */
        function updateFullscreenButtonState() {
            if (!fullscreenButton) return;
            const iconFullscreen = fullscreenButton.querySelector('.icon-fullscreen');
            const iconExitFullscreen = fullscreenButton.querySelector('.icon-exit-fullscreen');

            if (document.fullscreenElement) {
                iconFullscreen.style.display = 'none';
                iconExitFullscreen.style.display = 'block';
                fullscreenButton.title = uiStrings[currentLang].exitFullscreen;
            } else {
                iconFullscreen.style.display = 'block';
                iconExitFullscreen.style.display = 'none';
                fullscreenButton.title = uiStrings[currentLang].fullscreen;
            }
        }

        // --- 音声合成関連 ---
        let voices = [];
        let isVoiceGuidanceEnabled = true;
        let vvoxEngine; // TTSエンジンインスタンスを保持する変数

        function populateVoiceList() {
            if (!vvoxEngine || !vvoxEngine.isAvailable) {
            if (typeof speechSynthesis === 'undefined') { return; }
            voices = speechSynthesis.getVoices().filter(voice => voice.lang.startsWith(currentLang));
            voiceSelect.innerHTML = '';
            if (voices.length > 0) {
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute('data-name', voice.name);
                    voiceSelect.appendChild(option);
                });
                voiceSelect.disabled = false;
                // 保存された音声を選択 (言語が変わっても対応できるように)
                const savedVoiceName = localStorage.getItem('selectedVoiceName');
                if (savedVoiceName) {
                    const savedOption = Array.from(voiceSelect.options).find(opt => opt.getAttribute('data-name') === savedVoiceName);
                    if (savedOption) savedOption.selected = true;
                }
            } else {
                voiceSelect.disabled = true;
            }
            }
        }

        /**
         * 指定されたテキストを音声で読み上げます。
         * @param {string} text - 読み上げるテキスト
         * @param {string} lang - 言語コード (e.g., 'ja-JP')
         */
        function speak(text, lang) {
            // VOICEVOXが利用可能で、話者が選択されている場合はそちらを優先
            if (vvoxEngine && vvoxEngine.isAvailable && vvoxEngine.speakerId !== null) {
                if (isVoiceGuidanceEnabled) {
                    vvoxEngine.speak(text);
                }
            } else if ('speechSynthesis' in window && isVoiceGuidanceEnabled) {
                // 既存の発言があればキャンセル
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.rate = 1.1; // 少し早口に
                utterance.pitch = 1.0;

                const selectedVoiceName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
                if (selectedVoiceName) {
                    const selectedVoice = voices.find(voice => voice.name === selectedVoiceName);
                    if (selectedVoice) utterance.voice = selectedVoice;
                }

                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('このブラウザは音声合成をサポートしていません。');
            }
        }
        /**
         * UIの言語を設定します。
         * @param {string} lang - 言語コード ('ja' or 'en')
         */
        function setLanguage(lang) {
            if (!uiStrings[lang]) return;
            currentLang = lang;
            document.documentElement.lang = lang;

            // data-i18n属性を持つ静的なテキストを更新
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                if (uiStrings[lang][key]) {
                    el.textContent = uiStrings[lang][key];
                }
            });

            // data-i18n-placeholder属性を持つプレースホルダーを更新
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.dataset.i18nPlaceholder;
                if (uiStrings[lang][key]) {
                    el.placeholder = uiStrings[lang][key];
                }
            });

            // 検索ボックスのプレースホルダーを更新
            const searchInput = document.getElementById('pac-input');
            if (searchInput) {
                searchInput.placeholder = uiStrings[lang].searchForPlace || 'Search for a Place';
            }

            // 状態によってテキストが変わるボタンを更新
            toggleTourButton.textContent = isTourRunning ? uiStrings[lang].stopTour : uiStrings[lang].startTour;
            bleConnectButton.textContent = (bleDevice && bleDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectPower;
            hrConnectButton.textContent = (hrDevice && hrDevice.gatt.connected) ? uiStrings[lang].disconnect : uiStrings[lang].connectHr;
            logToggleButton.textContent = isLogging ? uiStrings[lang].stopLog : uiStrings[lang].startLog;
            updateFullscreenButtonState();

            // マーカーのタイトルを更新
            if (startMarker) startMarker.setTitle(uiStrings[lang].startPoint);
            if (endMarker) endMarker.setTitle(uiStrings[lang].endPoint);
            if (currentLocationMarker) currentLocationMarker.setTitle(uiStrings[lang].currentLocation);

            // 声色の選択肢を更新
            populateVoiceList();

            // 言語スイッチャーボタンのアクティブ状態を更新
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.lang === lang));
        }

        // ドロップダウンの表示/非表示を切り替える
        routeSettingsButton.addEventListener('click', (event) => {
            // ツアー実行中は経路設定を変更できない
            if (isTourRunning) {
                showMessage(uiStrings[currentLang].routeSettingsDisabled, true);
                return;
            }
            event.stopPropagation();
            routeSettingsDropdown.classList.toggle('show');

            // ログ記録中は出発地を編集不可にする
            // メニューが開かれるたびに状態をチェックして設定する
            originInput.disabled = isLogging;
        });

        // ドロップダウン外をクリックしたら閉じる
        window.addEventListener('click', (event) => {
            if (routeSettingsDropdown.classList.contains('show') && !routeSettingsDropdown.contains(event.target) && !routeSettingsButton.contains(event.target)) {
                routeSettingsDropdown.classList.remove('show');
            }
            if (settingsDropdown.classList.contains('show') && !settingsContainer.contains(event.target)) {
                settingsDropdown.classList.remove('show');
            }
        });

        /**
         * 巡回モードを設定し、UIを更新します。
         * @param {string} mode - ツアーモード ('DRIVING', 'BICYCLING', 'WALKING')
         */
        function setTravelMode(mode, keepValue = false) {
            currentTravelMode = mode;
            travelModeButtons.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            if (!keepValue) {
                intervalInput.value = defaultSettings[mode].interval;
                speedInput.value = defaultSettings[mode].speed;
            }
            
        }

        travelModeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                setTravelMode(btn.dataset.mode);
            });
        });

        directionButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                directionOffset = parseInt(btn.dataset.angle, 10);

                directionButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                if (!isTourRunning && routePoints.length > 0) {
                    updateStreetView();
                }
            });
        });

        // 手動ブーストボタンのクリックイベント
        boostButton.addEventListener('click', () => {
            isBoostActive = !isBoostActive;
            boostButton.classList.toggle('active', isBoostActive);
            boostButton.title = isBoostActive ? uiStrings[currentLang].boostOn : uiStrings[currentLang].boost;
        });

        // --- 設定メニュー関連のイベントリスナー ---
        settingsButton.addEventListener('click', (event) => {
            event.stopPropagation();
            settingsDropdown.classList.toggle('show');
        });

        voiceGuidanceToggle.addEventListener('change', () => {
            isVoiceGuidanceEnabled = voiceGuidanceToggle.checked;
            localStorage.setItem('isVoiceGuidanceEnabled', isVoiceGuidanceEnabled);
        });

        voiceSelect.addEventListener('change', () => {
            if (vvoxEngine && vvoxEngine.isAvailable) {
                const selectedSpeakerId = voiceSelect.value;
                vvoxEngine.setSpeakerId(selectedSpeakerId);
                localStorage.setItem('vvoxSpeakerId', selectedSpeakerId);
            } else {
                const selectedVoiceName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
                if (selectedVoiceName) localStorage.setItem('selectedVoiceName', selectedVoiceName);
            }
        });

        geocodeIntervalInput.addEventListener('input', () => {
            const interval = parseInt(geocodeIntervalInput.value, 10);
            if (!isNaN(interval) && interval >= 100) {
                geocodeIntervalDistance = interval;
                localStorage.setItem('geocodeIntervalDistance', geocodeIntervalDistance);
            }
        });

        autoBoostThresholdInput.addEventListener('input', () => {
            const threshold = parseInt(autoBoostThresholdInput.value, 10);
            if (!isNaN(threshold)) {
                autoBoostThreshold = threshold;
                localStorage.setItem('autoBoostThreshold', autoBoostThreshold);
            }
        });

        /**
         * マップ上のすべてのマーカーをクリアします。
         */
        function clearMarkers() {
            if (startMarker) startMarker.setMap(null);
            if (endMarker) endMarker.setMap(null);
            if (currentLocationMarker) currentLocationMarker.setMap(null);
            startMarker = null;
            endMarker = null;
            currentLocationMarker = null;
        }

        /**
         * ツアー状態を初期化します。
         */
        function resetTourState() {
            stopTour();
            clearMarkers();
            directionsRenderer.setDirections({ routes: [] });
            if (gpxRoutePolyline) {
                gpxRoutePolyline.setMap(null);
                gpxRoutePolyline = null;
            }
            routePoints = [];
            routeElevations = [];            
            totalDistance = 0;
            currentPositionDistance = 0;
            if (!isLogging) {
                distanceTraveled = 0; // 走行距離もリセット
            }
            currentPointIndex = 0;

            // パワーソースに接続されていない場合のみ、現在の移動モードのデフォルト速度を再設定
            if (!bleDevice || !bleDevice.gatt.connected) {
                setTravelMode(currentTravelMode, true); // これでspeedInputとmanualSpeedKmhが更新される
            }
            document.getElementById('elevation').textContent = `N/A`;
            document.getElementById('gradient').textContent = `N/A`;
            updateInfoDisplay();
            toggleTourButton.disabled = true;

            // グラフをクリアして非表示にする
            const container = document.getElementById('elevation-chart-container');
            const canvas = document.getElementById('elevation-chart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            container.style.display = 'none';
        }

        /**
         * 経路データを処理し、マップとストリートビューを初期化します。
         * @param {google.maps.LatLng[]} path - 経路の座標の配列
         * @param {Array<{location: google.maps.LatLng, elevation: number}>} [gpxElevationData=null] - GPXから読み込んだ標高データ（オプション）
         */
        async function processRoute(path, gpxElevationAvailable = false) {
            routePoints = path;
            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noStreetView);
                return;
            }

            const firstPoint = routePoints[0];
            const lastPoint = routePoints[routePoints.length - 1];

            // 最初に全ポイントの累積距離を計算
            cumulativeDistances = [0];
            for (let i = 1; i < path.length; i++) {
                cumulativeDistances.push(cumulativeDistances[i - 1] + getDistance(path[i - 1], path[i]));
            }
            totalDistance = cumulativeDistances[cumulativeDistances.length - 1];

            try {
                // GPXから標高データが渡された場合、それを利用する
                if (gpxElevationAvailable) {
                    console.log("Using elevation data from GPX file.");
                // if (gpxElevationData && gpxElevationData.length > 0) {
                //     // GPXの標高データを、経路の各点に線形補間して割り当てる
                //     routeElevations = new Array(path.length);
                //     let gpxIndex = 0;
                //     let gpxCumulativeDistance = getDistance(gpxElevationData[0].location, gpxElevationData[gpxIndex + 1].location);
                //     for (let i = 0; i < path.length; i++) {
                //         const pointDistance = cumulativeDistances[i];
                //         // gpxElevationDataの各要素は { location: google.maps.LatLng, elevation: number } という形式
                //         // getDistanceに渡すのは google.maps.LatLng オブジェクトにする
                //         // GPX経路上の累積距離を計算する必要がある
                //         if (gpxIndex < gpxElevationData.length - 2 && pointDistance > gpxCumulativeDistance) {
                //             gpxCumulativeDistance += getDistance(gpxElevationData[gpxIndex].location, gpxElevationData[gpxIndex + 1].location);
                //             gpxIndex++;
                //             routeElevations[i] = gpxElevationData[gpxIndex].elevation;
                //         }
                //         else {
                //             routeElevations[i] = gpxElevationData[gpxIndex].elevation;
                //         }
                //     }
                } else {
                // 1. 経路長に応じてサンプリング距離を動的に決定する
                // const minSamplingDistance = 25;  // 最小サンプリング距離 (m)
                // const maxSamplingDistance = 150; // 最大サンプリング距離 (m)
                // let samplingDistance = (totalDistance >= 1000) ? (totalDistance * 0.025) : minSamplingDistance;
                // samplingDistance = Math.min(samplingDistance, maxSamplingDistance);

                const interpolationInterval = parseFloat(intervalInput.value, 10);
                const samplingDistance = interpolationInterval * 10;

                sampledPointsData = [{ point: path[0], distance: 0 }];
                let distanceSinceLastSample = 0;
                for (let i = 1; i < path.length; i++) {
                    const dist = cumulativeDistances[i] - cumulativeDistances[i-1];
                    distanceSinceLastSample += dist;
                    if (distanceSinceLastSample >= samplingDistance) {
                        sampledPointsData.push({ point: path[i], distance: cumulativeDistances[i] });
                        distanceSinceLastSample = 0;
                    }
                }
                // 最後のポイントがサンプリングされていない場合、追加する
                // 最後のポイントへの残り間隔がサンプリング間隔の半分より短いときは追加でなく書き換え
                const lastSampledDistance = sampledPointsData[sampledPointsData.length - 1].distance;
                if (lastSampledDistance < totalDistance) {
                    if ((totalDistance - lastSampledDistance) < (samplingDistance / 2)) {
                        sampledPointsData[sampledPointsData.length - 1].point = path[path.length - 1];
                        sampledPointsData[sampledPointsData.length - 1].distance = totalDistance;
                    }
                    else {
                        sampledPointsData.push({ point: path[path.length - 1], distance: totalDistance });
                    }
                }

                // 2. サンプリングした点の標高を取得
                const sampledPoints = sampledPointsData.map(d => d.point);
                const sampleLimit = 512; // APIの上限
                let allElevationResults = [];

                for (let i = 0; i < sampledPoints.length; i += sampleLimit) {
                    const chunk = sampledPoints.slice(i, i + sampleLimit);
                    const { results: chunkResults } = await elevationService.getElevationForLocations({
                        locations: chunk,
                    });
                    if (!chunkResults || chunkResults.length !== chunk.length) {
                        const errorMessage = chunkResults ? `Expected ${chunk.length} results but got ${chunkResults.length}.` : 'No results from API.';
                        throw new Error(`Elevation fetch error in chunk [${i}-${i+chunk.length-1}]: ${errorMessage}`);
                    }
                    allElevationResults = allElevationResults.concat(chunkResults);
                }

                if (allElevationResults.length !== sampledPoints.length) {
                    throw new Error('Failed to get elevation for all sampled points.');
                }
                sampledPointsData.forEach((data, i) => {
                    data.elevation = allElevationResults[i].elevation;
                });

                // 移動平均法による一般的なスムージングを適用
                // const smoothingWindowSize = 5; // スムージング強度（奇数を推奨）
                // const trimRatio = 2; // 上下から除外する割合（例: 0.2 = 上下20%ずつ除外）
                // sampledPointsData = applyMovingAverage(sampledPointsData, smoothingWindowSize, trimRatio);

                if (currentTravelMode !== 'WALKING') {
                    // 徒歩は以外では勾配によるフィルタリング
                    console.log(`Applying elevation smoothing`);
                    sampledPointsData = correctAnomalyElevation(sampledPointsData, 25);
                }
                                // 3. 元の経路の各点の標高を計算する
                routeElevations = new Array(path.length);

                // サンプリングされた点が2つ未満の場合（経路が非常に短い場合など）、
                // 全ポイントを最初の点の標高にするか、0で埋める
                if (sampledPointsData.length < 2) {
                    const singleElevation = sampledPointsData.length === 1 ? sampledPointsData[0].elevation : 0;
                    routeElevations.fill(singleElevation);
                } else {
                    // 線形補間で各点の標高を計算
                    let currentSegmentIndex = 0;
                    for (let i = 0; i < path.length; i++) {
                        const pointDistance = cumulativeDistances[i];
                        // 現在の点がどの補間セグメントに属するかを見つける
                        while (currentSegmentIndex < sampledPointsData.length - 2 && pointDistance > sampledPointsData[currentSegmentIndex + 1].distance) {
                            currentSegmentIndex++;
                        }
                        const startSample = sampledPointsData[currentSegmentIndex];
                        const endSample = sampledPointsData[currentSegmentIndex + 1];
                        const segmentDistance = endSample.distance - startSample.distance;
                        const distanceIntoSegment = pointDistance - startSample.distance;
                        const fraction = (segmentDistance > 0) ? distanceIntoSegment / segmentDistance : 0;
                        const interpolatedElevation = startSample.elevation + (endSample.elevation - startSample.elevation) * Math.max(0, Math.min(1, fraction));
                        routeElevations[i] = interpolatedElevation;
                    }
                }

                }

                    // const indexDiv = 5;
                    // for (let i = indexDiv; i < path.length - indexDiv * 2; i += (indexDiv * 2)) {
                    //     const pointDistance = cumulativeDistances[i];
                    //     const pointElvation = routeElevations[i];
                    //     const endDivIndex = (i + indexDiv * 2) < path.length ? (i + indexDiv * 2) : path.length - 1;
                    //     const endDivDistance = cumulativeDistances[endDivIndex];
                    //     const endDivElevation = routeElevations[endDivIndex];
                    //     const divdGradient = (endDivElevation - pointElvation) / (endDivDistance - pointDistance);
                    //     for (let j = i + 1; j < endDivIndex; j++ ) {
                    //         const currentDistanceDiff = cumulativeDistances[j] - cumulativeDistances[i];
                    //         const currentDivElevation = pointElvation + (divdGradient * currentDistanceDiff);
                    //         const smoothedElevation = (currentDivElevation + routeElevations[j]) / 2;
                    //         const orgRouteElevation = routeElevations[j];
                    //         routeElevations[j] = smoothedElevation;
                    //         const elevationDiff = smoothedElevation - orgRouteElevation;
                    //         if (Math.abs(elevationDiff) > 0.5) {
                    //             console.log(`large eleveation diff: ${elevationDiff}`);
                    //         }
                    //     }
                    // }

            

            const halfWindow = 10;

            for (let i = 0; i < routeElevations.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(routeElevations.length, i + halfWindow + 1);
                const windowSlice = routeElevations.slice(start, end);
                
                const sum = windowSlice.reduce((acc, val) => acc + val, 0);
                const average = sum / windowSlice.length;
                
                routeElevations[i] = average;
            }
                    console.log("applied Moving Average");


                    // const forewardIndexOffset = 20;
                    // for (let i = 1; i < path.length - 2; i++) {
                    //     const pointDistance = cumulativeDistances[i];
                    //     const pointElvation = routeElevations[i];
                    //     const forewardIndex = (i + forewardIndexOffset) < path.length ? (i + forewardIndexOffset) : path.length - 1;
                    //     const forewardDistance = cumulativeDistances[forewardIndex];
                    //     const forewardElevation = routeElevations[forewardIndex];
                    //     const forewardGradient = (forewardElevation - pointElvation) / (forewardDistance - pointDistance);
                    //     const nextDistanceDiff = cumulativeDistances[i + 1] - cumulativeDistances[i];
                    //     const smoothedElevation = pointElvation + (forewardGradient * nextDistanceDiff);
                    //     //console.log('routeindex: ${i + 1} orgElev: ${routeElevations[i + 1].toFixed(2)} smoothedElev: ${smoothedElevation.toFixed(2)');
                    //     routeElevations[i + 1] = smoothedElevation;
                    // }
                // 4. 全ての点の標高データに移動平均を適用してさらに平滑化する
                //const finalSmoothedPoints = applyMovingAverage(routeElevations.map((elev, i) => ({ elevation: elev, distance: cumulativeDistances[i] })), 21);
                //routeElevations = finalSmoothedPoints.map(p => p.elevation);

                // 事前の勾配計算は廃止
                showMessage(uiStrings[currentLang].elevationProcessed, false);
            } catch (error) {
                showMessage(uiStrings[currentLang].elevationError, true);
                console.error("Elevation processing error:", error);
                routeElevations = new Array(routePoints.length).fill(0);
            }

            startMarker = new google.maps.Marker({
                map: map,
                position: firstPoint,
                title: uiStrings[currentLang].startPoint,
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, // 三角形
                    scale: 7,
                    fillColor: '#2ecc71', // 緑色
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: '#ffffff', // 白い縁取り
                    rotation: 90 // 上向きにする
                },
                zIndex: 1000
            });
            endMarker = new google.maps.Marker({
                map: map,
                position: lastPoint,
                title: uiStrings[currentLang].endPoint,
                icon: {
                    path: 'M -5,-5 5,-5 5,5 -5,5 Z', // 四角形
                    scale: 1.5,
                    fillColor: '#e74c3c', // 赤色
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: '#ffffff' // 白い縁取り
                },
                zIndex: 1000
            });
            currentLocationMarker = new google.maps.Marker({
                map: map,
                title: uiStrings[currentLang].currentLocation,
                // アイコンとしてSVG画像を直接指定する (データURI形式)
                icon: {
                    url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 384 512">
                            <path fill="#2ecc71" d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67a24 24 0 0 1-35.464 0z"/>
                            <circle cx="192" cy="192" r="64" fill="white"/>
                        </svg>
                    `)}`,
                    scaledSize: new google.maps.Size(36, 48), // 表示サイズ
                    anchor: new google.maps.Point(18, 48)     // ピンの先端の位置
                },
                position: firstPoint,
                zIndex: 9999,
            });

            if (panorama) {
                panorama.setPosition(firstPoint);
                map.panTo(firstPoint);

                try {
                    if (routePoints.length > 1) {
                        const heading = getHeading(routePoints[0], routePoints[1]);
                        if (!isNaN(heading)) {
                            panorama.setPov({ heading: (heading + directionOffset + 360) % 360, pitch: 0 });
                        }
                    }
                } catch (e) {
                    console.error("Error setting initial POV:", e);
                }
            }

            showMessage(uiStrings[currentLang].routeFound, false);
            // 経路の開始地点を出発地として設定する
            setOriginToGeocodedLocation(firstPoint);

            currentGradient = calculateCurrentGradient();
            updateInfoDisplay();
            toggleTourButton.disabled = false;

            document.getElementById('elevation-chart').style.cursor = 'pointer';
            // 初期グラフを描画 (現在地は0)
            drawElevationChart(0);
        }

        /**
         * ユーザー入力に基づいて経路を計算し表示します。
         */
        function calculateAndDisplayRoute() {
            resetTourState();

            const originValue = originInput.value;
            const destinationValue = destinationInput.value;
            const interpolationInterval = parseFloat(intervalInput.value);

            if (!originValue || !destinationValue) {
                showMessage(uiStrings[currentLang].originDestRequired);
                return;
            }
            if (isNaN(interpolationInterval) || interpolationInterval <= 0) {
                showMessage(uiStrings[currentLang].invalidInterval);
                return;
            }

            // BICYCLING_ROADはAPIリクエスト時にはDRIVINGとして扱う
            const apiTravelMode = currentTravelMode === 'BICYCLING_ROAD' 
                ? google.maps.TravelMode.DRIVING 
                : google.maps.TravelMode[currentTravelMode];

            const request = {
                origin: originLatLng || originValue,
                destination: destinationLatLng || destinationValue,
                travelMode: apiTravelMode
            };

            // 「自転車(車道)」モードの場合、高速道路と有料道路を避ける
            if (currentTravelMode === 'BICYCLING_ROAD') {
                request.avoidHighways = true;
                request.avoidTolls = true;
            }

            directionsService.route(request).then((response) => {
                if (response.status === 'OK') {                    
                    // 経路の色を赤に変更 (既に適用済みですが、確認のため記載)
                    directionsRenderer.setOptions({
                        polylineOptions: { strokeColor: '#e74c3c', strokeWeight: 5, strokeOpacity: 0.8 }
                    });
                    // overview_pathの代わりに、より詳細なstepsのpathを連結して使用する
                    const detailedPath = response.routes[0].legs.flatMap(leg => leg.steps.flatMap(step => step.path));
                    directionsRenderer.setDirections(response);

                    const interpolatedPath = [];
                    for (let i = 0; i < detailedPath.length - 1; i++) {
                        const p1 = detailedPath[i];
                        const p2 = detailedPath[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / (interpolationInterval * 2));
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                        }
                    }
                    interpolatedPath.push(detailedPath[detailedPath.length - 1]);

                    processRoute(interpolatedPath);
                } else {
                    throw new Error(`${uiStrings[currentLang].routeSearchFailed}${response.status}`);
                }
            }).catch((e) => {
                showMessage(uiStrings[currentLang].routeNotFound);
            });
        }

        loadGpxButton.addEventListener('click', () => {
            gpxFileInput.click();
        });

        gpxFileInput.addEventListener('change', (event) => {
            resetTourState();

            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxText = e.target.result;
                    const parser = new DOMParser();
                    const gpxDoc = parser.parseFromString(gpxText, 'application/xml');

                    const trkpts = gpxDoc.querySelectorAll('trkpt');
                    if (trkpts.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoTrackpoints);
                        return;
                    }

                    const gpxPoints = [];
                    let hasElevationData = false;
                    trkpts.forEach(pt => {
                        const lat = parseFloat(pt.getAttribute('lat'));
                        const lon = parseFloat(pt.getAttribute('lon'));
                        const eleEl = pt.querySelector('ele');
                        const ele = eleEl ? parseFloat(eleEl.textContent) : null;
                        if (!isNaN(lat) && !isNaN(lon)) {
                            gpxPoints.push({ lat: lat, lng: lon, ele: ele });
                            if (ele !== null) hasElevationData = true;
                        }
                    });

                    if (gpxPoints.length === 0) {
                        showMessage(uiStrings[currentLang].gpxNoCoordinates);
                        return;
                    }

                    const interpolationInterval = parseFloat(intervalInput.value);
                    const pathForPolyline = gpxPoints.map(p => new google.maps.LatLng(p.lat, p.lng));
                    const interpolatedPath = [];
                    routeElevations = [];
                    for (let i = 0; i < pathForPolyline.length - 1; i++) {
                        const p1 = pathForPolyline[i];
                        const p2 = pathForPolyline[i + 1];
                        const distance = getDistance(p1, p2);
                        const segments = Math.ceil(distance / (interpolationInterval * 2));
                        for (let j = 0; j < segments; j++) {
                            const fraction = j / segments;
                            interpolatedPath.push(interpolate(p1, p2, fraction));
                            if (hasElevationData) {
                                const elevation1 = gpxPoints[i].ele;
                                const elevation2 = gpxPoints[i + 1].ele;
                                routeElevations.push(elevation1 + (elevation2 - elevation1) * fraction);
                            }
                        }
                    }
                    interpolatedPath.push(pathForPolyline[pathForPolyline.length - 1]);
                    if (hasElevationData) {
                        routeElevations.push(gpxPoints[gpxPoints.length - 1].ele);
                    }

                    gpxRoutePolyline = new google.maps.Polyline({
                        path: pathForPolyline,
                        geodesic: true,
                        strokeColor: '#e74c3c', // 赤色に変更
                        strokeOpacity: 0.8,
                        strokeWeight: 5
                    });
                    gpxRoutePolyline.setMap(map);
                    
                    // GPXに標高データがある場合は、それをprocessRouteに渡す
                    // if (hasElevationData) {
                    //     const gpxPathWithElevation = gpxPoints.map(p => ({
                    //         location: new google.maps.LatLng(p.lat, p.lng),
                    //         elevation: p.ele
                    //     }));
                    //     processRoute(interpolatedPath, gpxPathWithElevation);
                    // } else {
                    //     processRoute(interpolatedPath);
                    // }
                    processRoute(interpolatedPath, hasElevationData);
                } catch (error) {
                    showMessage(uiStrings[currentLang].gpxParseError);
                }
            };
            reader.readAsText(file);
        });

        async function updateStreetView() {
            if (routePoints.length === 0 || currentPointIndex >= routePoints.length) return;

            const targetPosition = routePoints[currentPointIndex];

            try {
                const { data } = await streetViewService.getPanorama({
                    location: targetPosition,
                    radius: 100,
                    source: showUserContent ? google.maps.StreetViewSource.DEFAULT : google.maps.StreetViewSource.GOOGLE,
                    preference: google.maps.StreetViewPreference.NEAREST
                });

                if (data && data.location) {
                    const currentPanoId = panorama.getPano();
                    const newPanoId = data.location.pano;

                    if (newPanoId && newPanoId !== currentPanoId) {
                        panorama.setPosition(data.location.latLng);
                    }

                    if (currentPointIndex + 1 < routePoints.length) {
                        const heading = getHeading(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]);
                        if (!isNaN(heading)) {
                            panorama.setPov({ heading: (heading + directionOffset + 360) % 360, pitch: 0 });
                        }
                    }
                } else {
                    console.log(`No panorama found near point ${currentPointIndex}. Skipping Street View update.`);
                }
            } catch (e) {
                console.error(`Error getting panorama data for point ${currentPointIndex}:`, e);
                if (e.code) console.error(`Street View API Error Code: ${e.code}`);
            }
        }

        function updatePhysics() {
            const now = Date.now();
            const deltaTime = (now - lastPhysicsUpdateTime) / 1000; // 秒単位
            lastPhysicsUpdateTime = now;
            let currentSpeedMps = actualSpeedKmh / 3.6;

            // パワーソースが接続されている場合は物理モデルに基づいて速度を更新
            if (bleDevice && bleDevice.gatt.connected) {
                const C = PHYSICS_CONSTANTS;

                // 1. 抵抗力の計算 (ツアー実行中のみ物理モデルを適用)
                const gradientAngle = Math.atan(currentGradient / 100);
                const rollingResistanceForce = C.CRR * C.TOTAL_MASS * C.G * Math.cos(gradientAngle);
                const airResistanceForce = 0.5 * C.CDA * C.RHO * Math.pow(currentSpeedMps, 2);
                const gradientResistanceForce = C.TOTAL_MASS * C.G * Math.sin(gradientAngle);
                const totalResistanceForce = rollingResistanceForce + airResistanceForce + gradientResistanceForce;

                // 2. 推進力の計算
                // 速度が非常に遅い場合の発散を防ぐ (ツアー実行中のみ)
                const effectiveSpeed = Math.max(currentSpeedMps, C.MIN_SPEED_FOR_FORCE_CALC_MPS);
                const boostedPower = isBoostActive ? currentPower * BOOST_FACTOR : currentPower;
                const propulsiveForce = (boostedPower * C.DRIVETRAIN_EFFICIENCY) / effectiveSpeed;

                // オートブーストのロジック
                if (autoBoostThreshold > 0) {
                    if (currentGradient >= autoBoostThreshold) {
                        isBoostActive = true;
                    } else {
                        isBoostActive = false;
                    }
                    boostButton.classList.toggle('active', isBoostActive);
                }
                // 3. 加速度と新しい速度の計算
                if (isTourRunning) {
                    const netForce = propulsiveForce - totalResistanceForce;
                    const acceleration = netForce / C.TOTAL_MASS;
                    currentSpeedMps += acceleration * deltaTime;
                    currentSpeedMps = Math.max(0, currentSpeedMps); // 速度が負にならないように
                }

                // 実際の移動速度を更新
                actualSpeedKmh = currentSpeedMps * 3.6;

            } else {
                // パワーソースが接続されていない場合は、手動入力された速度(manualSpeedKmh)を実際の速度(actualSpeedKmh)に反映する
                actualSpeedKmh = manualSpeedKmh;
                currentSpeedMps = actualSpeedKmh / 3.6;
            }

            // 現在の位置を計算（ログ記録のために isTourRunning の外で定義）
            const currentPosition = (routePoints.length > 0) ? routePoints[currentPointIndex] : null;

            // ツアー実行中のみ位置やUIを更新する
            if (isTourRunning) {
                const deltaDistance = currentSpeedMps * deltaTime;
                currentPositionDistance += deltaDistance;
                distanceTraveled += deltaDistance; // 実際に走行した距離も加算
                distanceSinceLastGeocode += deltaDistance;
                distanceSinceLastSvUpdate += deltaDistance;

                if (currentPositionDistance >= totalDistance) {
                    currentPositionDistance = totalDistance;
                    currentPointIndex = routePoints.length - 1;
                    if (currentLocationMarker && routePoints.length > 0) {
                        currentLocationMarker.setPosition(routePoints[currentPointIndex]);
                    }
                    updateInfoDisplay();
                    stopTour();
                    announceLocation(routePoints[currentPointIndex], 'arrival');
                    showMessage(uiStrings[currentLang].destinationReached, false);
                    return;
                }

                // マーカーは常に正確な現在地に表示
                currentLocationMarker.setPosition(currentPosition);

                // 現在のインデックスを更新
                const lastPointIndex = currentPointIndex;
                while (currentPointIndex < cumulativeDistances.length - 1 && currentPositionDistance > cumulativeDistances[currentPointIndex + 1]) {
                    currentPointIndex++;
                }

                if (currentPointIndex !== lastPointIndex) { // currentPointIndex変化したら勾配を再計算
                    let tilt = 0;
                    let heading = 0;    //北が上（デフォルト）
                    let cameraCenter = currentPosition;
                    if (isVectorMap) {  //ベクターマップの場合
                        if (isTiltView) {   //チルト表示の場合
                            tilt = 75;
                            if (currentPointIndex > 0 && currentPointIndex + 1 < routePoints.length) {
                                heading = getHeading(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]);
                            }
                            // ズームレベルに応じてオフセット距離を計算 (ズームアウトするほど遠くを見る)
                            // ズームレベル17で約150m、ズームレベル12で約4800mになるような計算式
                            const zoomLevel = map.getZoom() || 17;
                            const lookAheadDistance = 300 * Math.pow(2, 17 - zoomLevel);
                            cameraCenter = google.maps.geometry.spherical.computeOffset(currentPosition, lookAheadDistance, heading);
                        }
                    }
                    map.moveCamera({ center: cameraCenter, tilt: tilt});
                    map.setHeading(heading);

                    const newGradient = calculateCurrentGradient();
                    //一瞬で大きな変化をするのを抑える
                    currentGradient = Math.max(currentGradient - 3, Math.min(newGradient, currentGradient + 3));
                }


                updateInfoDisplay();

                if (distanceSinceLastSvUpdate >= STREETVIEW_UPDATE_DISTANCE) {
                    updateStreetView();
                    distanceSinceLastSvUpdate = 0;
                }

                if (distanceSinceLastGeocode >= geocodeIntervalDistance) {
                    announceLocation(currentPosition, 'moving');
                    distanceSinceLastGeocode = 0;
                }
            }

            if (isLogging) {
                // ツアーが停止している場合、ログに記録する速度は0にする
                const loggedSpeedKmh = isTourRunning ? actualSpeedKmh : 0;

                const currentElevation = (routeElevations.length > currentPointIndex) ? routeElevations[currentPointIndex] : 0;
                logData.push({
                    timestamp: new Date().toISOString(),
                    position: currentPosition,
                    elevation: currentElevation,
                    power: currentPower,
                    cadence: currentCadence,
                    heartRate: currentHeartRate,
                    distance: distanceTraveled, // ログには実際に走行した総距離を記録
                    speed: loggedSpeedKmh // km/hで記録 (actualSpeedKmh)
                });
            }
        }

        /**
         * 指定された距離に最も近い経路上のポイントのインデックスを検索します。
         * @param {number} distance - 検索する距離 (m)
         * @returns {number} - 経路ポイントのインデックス
         */
        function findIndexByDistance(distance) {
            if (distance <= 0) return 0;
            if (distance >= totalDistance) return routePoints.length - 1;

            // 二分探索の方が効率的ですが、今回は線形探索で実装します
            let index = cumulativeDistances.findIndex(d => d >= distance);
            return index === -1 ? routePoints.length - 1 : index;
        }

        /**
         * 指定された距離にツアーの現在地をジャンプさせます。
         * @param {number} newDistance - ジャンプ先の距離 (m)
         */
        function jumpToDistance(newDistance) {
            if (routePoints.length < 2) return;

            // 距離を経路の範囲内に収める
            newDistance = Math.max(0, Math.min(newDistance, totalDistance));
            currentPositionDistance = newDistance;

            // 新しい現在地のインデックスを探す
            let newIndex = 0;
            while (newIndex < cumulativeDistances.length - 1 && newDistance > cumulativeDistances[newIndex + 1]) {
                newIndex++;
            }
            currentPointIndex = newIndex;
            currentGradient = calculateCurrentGradient();

            // マーカーの位置を即時更新
            const newPosition = routePoints[currentPointIndex];
            if (currentLocationMarker) {
                currentLocationMarker.setPosition(newPosition);
                map.panTo(newPosition);
            }
            
            // ストリートビューを即時更新
            updateStreetView();

            // ジャンプした地点を出発地として設定
            setOriginToGeocodedLocation(newPosition);

            // 情報表示とグラフを更新
            updateInfoDisplay();
        }
        /**
         * 現在地周辺の標高データから線形回帰を用いて現在の勾配を計算します。
         * @param {number} [pointsToConsider=20] - 勾配計算に考慮するデータ点の数（現在地を含む前方）。
         * @returns {number} - 計算された勾配 (%)。
         */
        function calculateCurrentGradient(fwPointsToConsider = 3, bwPointsToConsider = 3) {
            if (routeElevations.length < 2 || currentPointIndex >= routeElevations.length) {
                return 0;
            }

            // 現在地を中心として、前後のデータ点を収集する
            //const halfPoints = Math.floor(pointsToConsider / 2);
            const startIndex = Math.max(0, currentPointIndex - bwPointsToConsider);
            const endIndex = Math.min(routeElevations.length, currentPointIndex + fwPointsToConsider);

            if (endIndex - startIndex < 2) {
                // 2点未満では勾配を計算できない
                // 経路の始点か終点付近でデータが少ない場合は、直近2点の勾配を返す（簡易版）
                if (currentPointIndex > 0) {
                    const elevChange = routeElevations[currentPointIndex] - routeElevations[currentPointIndex - 1];
                    const distChange = cumulativeDistances[currentPointIndex] - cumulativeDistances[currentPointIndex - 1];
                    return distChange > 0 ? (elevChange / distChange) * 100 : 0;
                }
                return 0;
            }

            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const n = endIndex - startIndex;

            for (let i = startIndex; i < endIndex; i++) {
                const x = cumulativeDistances[i]; // 距離
                const y = routeElevations[i];     // 標高

                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
            }

            // 線形回帰の傾き(m)を計算: m = (n * Σ(xy) - Σx * Σy) / (n * Σ(x^2) - (Σx)^2)
            const numerator = n * sumXY - sumX * sumY;
            const denominator = n * sumX2 - sumX * sumX;

            if (denominator === 0) {
                // 垂直な線（ありえないが念のため）
                return 0;
            }

            const slope = numerator / denominator;

            // 傾きをパーセンテージに変換して返す
            return slope * 100;
        }
        /**
         * 指定された座標の地名を取得し、状況に応じた音声ガイダンスを再生します。
         * @param {google.maps.LatLng} location - 確認する場所の座標
         * @param {'departure' | 'moving' | 'arrival'} context - 'departure' (出発時), 'moving' (移動中), 'arrival' (到着時)
         */
        async function announceLocation(location, context) {
            if (!geocoder || !isVoiceGuidanceEnabled) return;

            try {
                const { results } = await geocoder.geocode({ location: location, language: currentLang });
                if (!results || !results[0]) return;
               // デバッグ用に取得した住所情報をコンソールに出力
                console.log('Geocoding Result:', results[0]?.formatted_address, results[0]?.address_components);

                const addressComponents = results[0].address_components;
                let prefecture = '', locality = '', sublocality = '';

                for (const component of addressComponents) {
                    if (component.types.includes('administrative_area_level_1')) {
                        prefecture = component.long_name;
                    }
                    if (locality === '' && component.types.includes('locality')) {
                        locality = component.long_name;
                    }
                    if (locality === '' && component.types.includes('administrative_area_level_2')) {
                        locality = component.long_name;
                    }
                    if (sublocality === '' && component.types.includes('sublocality_level_2')) {
                        sublocality = component.long_name;
                    }
                }
                const locationName = locality + sublocality;
                if (!locationName) return; // アナウンスに必要な地名がなければ終了

                if (mapSearchInput && mapSearchInput.value !== locationName) {
                    mapSearchInput.value = locationName;
                }

                const newFullMunicipality = sublocality ? (prefecture + locality + sublocality) : '';

                if (context === 'departure') {
                    const message = (uiStrings[currentLang].departingFrom || '{location} から出発します。').replace('{location}', locationName);
                    speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                    currentMunicipality = newFullMunicipality;
                } else if (context === 'moving') {
                    // 「町」レベルの地名が取得できた場合のみ比較・アナウンス
                    if (newFullMunicipality && newFullMunicipality !== currentMunicipality) {

                        if (currentMunicipality !== '') { // 初回はメッセージを表示しない
                            const messageTemplate = uiStrings[currentLang].municipalityGuidance || '{municipality} を移動中です。';
                            const message = messageTemplate.replace('{municipality}', locationName);
                            showMessage(message, false); // 緑色のメッセージボックス
                            speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                        }
                        currentMunicipality = newFullMunicipality;
                    }
                } else if (context === 'arrival') {
                    const message = (uiStrings[currentLang].arrivedAt || '{location} に到着しました。おつかれさまでした。').replace('{location}', locationName);
                    speak(message, currentLang === 'ja' ? 'ja-JP' : 'en-US');
                }
            } catch (e) {
                console.error(`Geocoding failed during location announcement ('${context}'):`, e);
            }
        }
        /**
         * 標高グラフのクリックイベントを処理します。
         * @param {MouseEvent} event - クリックイベント
         */
        function handleChartClick(event) {
            if (isTourRunning) {
                showMessage(uiStrings[currentLang].jumpDisabledDuringTour);
                return;
            }
            if (routePoints.length < 2) return;

            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;

            const padding = { top: 15, bottom: 30, left: 40, right: 40 };
            const chartWidth = canvas.clientWidth - padding.left - padding.right;

            if (x < padding.left || x > canvas.clientWidth - padding.right) {
                return;
            }

            const clickedX = x - padding.left;
            const fraction = Math.max(0, Math.min(1, clickedX / chartWidth));
            const newDistance = totalDistance * fraction;

            jumpToDistance(newDistance);
        }

        /**
         * 画面のスリープを防止するWake Lockを要求します。
         */
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockSentinel.addEventListener('release', () => {
                        // システムによってロックが解放された場合（例：タブの非表示化）
                        console.log('Screen Wake Lock was released by the system.');
                        wakeLockSentinel = null;
                    });
                    console.log('Screen Wake Lock is active.');
                } catch (err) {
                    console.error(`Failed to acquire wake lock: ${err.name}, ${err.message}`);
                }
            }
        };

        /**
         * Wake Lockを解放します。
         */
        const releaseWakeLock = async () => {
            if (wakeLockSentinel !== null) {
                await wakeLockSentinel.release();
                wakeLockSentinel = null;
                console.log('Screen Wake Lock released.');
            }
        };

        async function toggleTour() {
            if (isTourRunning) {
                await stopTour();
            } else {
                await startTour();
            }
        }

        async function startTour() {
            if (isTourRunning) return;

            if (routePoints.length === 0) {
                showMessage(uiStrings[currentLang].noRouteForTour);
                return;
            }

            // パワーソースが接続されていない場合のみ、手動速度をチェック
            if (!(bleDevice && bleDevice.gatt.connected)) {
                const speed = parseFloat(speedInput.value);
                if (isNaN(speed) || speed <= 0) {
                    showMessage(uiStrings[currentLang].invalidSpeed, true);
                    return;
                }                
                actualSpeedKmh = manualSpeedKmh;
            } else {
                // パワーソース接続時は0からスタート
                actualSpeedKmh = 0;
            }
            
            // 画面のスリープを防止
            await requestWakeLock();
            isTourRunning = true;
            toggleTourButton.textContent = uiStrings[currentLang].stopTour;
            tourStartTime = Date.now();
            lastPhysicsUpdateTime = Date.now();
            distanceSinceLastSvUpdate = 0;

            map.setZoom(17);

            // 出発地の地名を取得してアナウンス
            if (routePoints.length > 0) {
                announceLocation(routePoints[currentPointIndex], 'departure');
            }

            physicsIntervalId = setInterval(updatePhysics, PHYSICS_INTERVAL_MS);
        }

        async function stopTour() {
            if (physicsIntervalId) {
                clearInterval(physicsIntervalId);
                physicsIntervalId = null;
            }
            isTourRunning = false;
            // ログ記録中は物理演算ループが動き続けるため、速度をリセットしない
            actualSpeedKmh = 0;

            // 画面のスリープ防止を解除
            await releaseWakeLock();

            if (tourStartTime > 0) {
                totalTimeElapsed = totalTimeElapsed + (Date.now() - tourStartTime) / 1000;
                //console.log(formatTime(Date.now()));
                //console.log(formatTime(tourStartTime));
                //console.log(formatTime(totalTimeElapsed));
                tourStartTime = 0;
            }
            toggleTourButton.textContent = uiStrings[currentLang].startTour;
            updateInfoDisplay(); // UIとグラフの状態を更新

            // ツアー停止地点を次の出発地として設定
            if (currentLocationMarker) {
                setOriginToGeocodedLocation(currentLocationMarker.getPosition());
            }
        }

        async function connectToBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                await disconnectFromBleDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingDevice, false);
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [FTMS_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingDevice, false);
                const server = await bleDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const ftmsService = await server.getPrimaryService(FTMS_SERVICE_UUID);
                ftmsCharacteristic = await ftmsService.getCharacteristic(INDOOR_BIKE_DATA_UUID);

                await ftmsCharacteristic.startNotifications();
                ftmsCharacteristic.addEventListener('characteristicvaluechanged', handleFTMSData);

                showMessage(uiStrings[currentLang].ftmsConnected, false);
                bleConnectButton.textContent = uiStrings[currentLang].disconnect;
                bleConnectButton.style.backgroundColor = '#e74c3c';
                speedInput.readOnly = true; // 速度入力を読み取り専用に
                actualSpeedKmh = 0;
                boostButton.style.display = 'block'; // ブーストボタンを表示
                boostButton.title = uiStrings[currentLang].boost;

            } catch (error) {
                console.error(`${uiStrings[currentLang].btConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].btConnectionError}${error.message}`);
                bleConnectButton.textContent = uiStrings[currentLang].connectPower;
                bleConnectButton.style.backgroundColor = '#3498db';
                bleDevice = null;
                ftmsCharacteristic = null;
            }
        }

        async function disconnectFromBleDevice() {
            if (bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].deviceDisconnected, false);
            }
            if (ftmsCharacteristic) {
                ftmsCharacteristic.removeEventListener('characteristicvaluechanged', handleFTMSData);
                ftmsCharacteristic = null;
            }
            bleConnectButton.textContent = uiStrings[currentLang].connectPower;
            bleConnectButton.style.backgroundColor = '#3498db';
            speedInput.readOnly = false; // 速度入力を編集可能に戻す
            actualSpeedKmh = 0;
            boostButton.style.display = 'none'; // ブーストボタンを非表示
            isBoostActive = false;
            boostButton.classList.remove('active');
            document.getElementById('power-display').textContent = '0 W';
            document.getElementById('cadence-display').textContent = '0 rpm';
            await stopTour(); // 切断時にツアーを停止
        }

        async function connectToHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                disconnectFromHrDevice();
                return;
            }

            try {
                showMessage(uiStrings[currentLang].searchingHr, false);
                hrDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [HR_SERVICE_UUID] }]
                });

                showMessage(uiStrings[currentLang].connectingHr, false);
                const server = await hrDevice.gatt.connect();
                showMessage(uiStrings[currentLang].gattConnected, false);

                const hrService = await server.getPrimaryService(HR_SERVICE_UUID);
                hrCharacteristic = await hrService.getCharacteristic(HR_MEASUREMENT_UUID);

                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);

                showMessage(uiStrings[currentLang].hrConnected, false);
                hrConnectButton.textContent = uiStrings[currentLang].disconnect;
                hrConnectButton.style.backgroundColor = '#e74c3c';

            } catch (error) {
                console.error(`${uiStrings[currentLang].hrConnectionFailed}`, error);
                showMessage(`${uiStrings[currentLang].hrConnectionError}${error.message}`);
                hrConnectButton.textContent = uiStrings[currentLang].connectHr;
                hrConnectButton.style.backgroundColor = '#3498db';
                hrDevice = null;
                hrCharacteristic = null;
            }
        }

        function disconnectFromHrDevice() {
            if (hrDevice && hrDevice.gatt.connected) {
                hrDevice.gatt.disconnect();
                showMessage(uiStrings[currentLang].hrDisconnected, false);
            }
            if (hrCharacteristic) {
                hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                hrCharacteristic = null;
            }
            hrConnectButton.textContent = uiStrings[currentLang].connectHr;
            hrConnectButton.style.backgroundColor = '#3498db';
            document.getElementById('hr-display').textContent = '0 bpm';
        }

        /**
         * BLEから受信した心拍数データを処理します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            const rate16Bits = (flags & 0x1) !== 0;
            let heartRate;
            if (rate16Bits) {
                heartRate = value.getUint16(1, true); // Little endian
            } else {
                heartRate = value.getUint8(1);
            }
            currentHeartRate = heartRate;
            document.getElementById('hr-display').textContent = `${currentHeartRate} bpm`;
        }

        /**
         * ログ記録の開始/終了を切り替えます。
         */
        function toggleLogging() {
            if (!isLogging) {
                // ログ記録を開始
                isLogging = true;
                logData = []; // ログを初期化
                logStartDistance = distanceTraveled; // ログ開始時の走行距離を記録
                logStartTime = Date.now(); // ログ開始時刻を記録
                logToggleButton.textContent = uiStrings[currentLang].stopLog;
                logToggleButton.style.backgroundColor = '#f39c12'; // 記録中を示す色
                showMessage(uiStrings[currentLang].logStarted, false);

                // 物理演算ループが動いていなければ開始する
                if (!physicsIntervalId) {
                    lastPhysicsUpdateTime = Date.now();
                    physicsIntervalId = setInterval(updatePhysics, PHYSICS_INTERVAL_MS);
                }
            } else {
                // ログ記録を終了
                isLogging = false;
                logToggleButton.textContent = uiStrings[currentLang].startLog;
                logToggleButton.style.backgroundColor = '#3498db';
                showMessage(uiStrings[currentLang].logStopped, false);

                // ツアーも停止していれば、物理演算ループを止める
                if (!isTourRunning && physicsIntervalId) {
                    clearInterval(physicsIntervalId);
                    physicsIntervalId = null;
                }

                if (logData.length > 1) {
                    if (confirm(uiStrings[currentLang].confirmSaveTcx)) {
                        saveLogAsTcx();
                    }
                }
            }
        }

        /**
         * 記録したログをTCXファイルとして保存します。
         */
        function saveLogAsTcx() {
            let maxSpeedMs = 0; // m/s単位での最大速度

            let trackpointsXml = logData.map(p => {
                let positionXml = '';
                if (p.position) {
                    positionXml = `
            <Position>
              <LatitudeDegrees>${p.position.lat()}</LatitudeDegrees>
              <LongitudeDegrees>${p.position.lng()}</LongitudeDegrees>
            </Position>`;
                }

                let altitudeXml = '';
                if (p.elevation !== undefined) {
                    altitudeXml = `
            <AltitudeMeters>${p.elevation.toFixed(2)}</AltitudeMeters>`;
                }

                const speedMs = p.speed ? (p.speed * 1000 / 3600) : 0;
                if (speedMs > maxSpeedMs) {
                    maxSpeedMs = speedMs;
                }

                // Garmin拡張スキーマ(TPX)に速度を追加
                const tpxExtensions = `
              <TPX xmlns="http://www.garmin.com/xmlschemas/ActivityExtension/v2">
                <Watts>${p.power}</Watts>
                <Speed>${speedMs.toFixed(2)}</Speed>
              </TPX>`;

                return `
          <Trackpoint>
            <Time>${p.timestamp}</Time>${positionXml}${altitudeXml}
            <DistanceMeters>${p.distance.toFixed(2)}</DistanceMeters>
            <HeartRateBpm>
              <Value>${p.heartRate}</Value>
            </HeartRateBpm>
            <Cadence>${p.cadence}</Cadence>
            <Extensions>
              ${tpxExtensions}
            </Extensions>
          </Trackpoint>`;
            }).join('');

            const lapStartTimeISO = new Date(logStartTime).toISOString();
            const logEndTime = Date.now();
            const totalTimeSeconds = (logEndTime - logStartTime) / 1000;
            const totalDistanceMeters = distanceTraveled - logStartDistance;

            const tcxContent = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xsi:schemaLocation="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd" xmlns:ns5="http://www.garmin.com/xmlschemas/ActivityGoals/v1" xmlns:ns3="http://www.garmin.com/xmlschemas/ActivityExtension/v2" xmlns:ns2="http://www.garmin.com/xmlschemas/UserProfile/v2" xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ns4="http://www.garmin.com/xmlschemas/ProfileExtension/v1">
  <Activities>
    <Activity Sport="Biking">
      <Id>${lapStartTimeISO}</Id>
      <Lap StartTime="${lapStartTimeISO}">
        <TotalTimeSeconds>${totalTimeSeconds.toFixed(0)}</TotalTimeSeconds>
        <DistanceMeters>${totalDistanceMeters.toFixed(2)}</DistanceMeters>
        <MaximumSpeed>${maxSpeedMs.toFixed(2)}</MaximumSpeed>
        <Calories>0</Calories>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>${trackpointsXml}</Track>
      </Lap>
    </Activity>
  </Activities>
</TrainingCenterDatabase>`;

            const blob = new Blob([tcxContent], { type: 'application/vnd.garmin.tcx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;            const date = new Date(logStartTime);
            const filename = `activity_${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}.tcx`;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * BLEから受信したFTMSデータを処理します。
         * 速度を動的に計算し、UIを更新します。
         * @param {Event} event - characteristicvaluechanged イベント
         */
        function handleFTMSData(event) {
            const value = event.target.value;
            const data = new DataView(value.buffer);
            const rawData = Array.from(new Uint8Array(data.buffer)).join(' ');

            const flags = data.getUint16(0, true);
            let offset = 2;

            if (flags & 0x01) {
            }
            if (flags & 0x02) {
                offset += 2;
            }
            if (flags & 0x04) {
                const instantaneousCadence = data.getUint16(offset, true) / 2;
                currentCadence = instantaneousCadence.toFixed(0);
                document.getElementById('cadence-display').textContent = `${currentCadence} rpm`;
                offset += 2;
            }
            if (flags & 0x08) {
                offset += 2;
            }
            if (flags & 0x10) {
                offset += 3;
            }
            if (flags & 0x20) {
                offset += 2;
            }
            if (flags & 0x40) {
                const power = data.getInt16(offset, true);
                currentPower = power;
                document.getElementById('power-display').textContent = `${currentPower} W`;

                // ツアーが実行中でなく、パワーが検出され、かつ有効な経路が存在する場合にツアーを開始
                const hasValidRoute = routePoints.length > 0 && currentPositionDistance < totalDistance;
                if (!isTourRunning && power > 0 && hasValidRoute) {
                    startTour();
                    showMessage(uiStrings[currentLang].powerDetectedStart, false);
                }
                offset += 2;
            }
            if (flags & 0x80) {
                offset += 2;
            }
        }

        /**
         * 指定された場所にマップとストリートビューを移動させます。
         * @param {google.maps.places.PlaceResult} place - 移動先の場所情報
         */
        function jumpToPlace(place) {
            if (!place || !place.geometry || !place.geometry.location) return;

            const location = place.geometry.location;

            // 既存の経路やマーカーをクリア
            resetTourState();

            map.setCenter(location);
            map.setZoom(17);
            panorama.setPosition(location);

            // ストリートビューの向きを調整（利用可能な場合）
            streetViewService.getPanorama({ location: location, radius: 50 })
                .then(({ data }) => {
                    if (data && data.links && data.links.length > 0 && data.links[0].pano) {
                        // 最も近い道路の方向に向ける
                        const heading = google.maps.geometry.spherical.computeHeading(location, data.links[0].pano);
                        panorama.setPov({ heading: heading, pitch: 0, zoom: 1 });
                    } else {
                        panorama.setPov({ heading: 0, pitch: 0, zoom: 1 });
                    }
                })
                .catch(e => console.error("Could not set POV for jumped location:", e));
        }

        /**
         * formatted_addressから国名と郵便番号を除去して整形します。
         * @param {string} formattedAddress - Google Geocoding APIから返されるformatted_address
         * @param {Array<Object>} addressComponents - Google Geocoding APIから返されるaddress_components
         * @returns {string} - 整形された住所文字列
         */
        function formatAddress(formattedAddress, addressComponents) {
            // addressComponentsがなければ、元のformattedAddressをそのまま返す
            if (!addressComponents) return formattedAddress || '';

            // 日本語環境を優先し、住所を構成する要素を定義
            const desiredTypes = [
                'administrative_area_level_1', // 都道府県
                'locality',                      // 市区町村
                'sublocality_level_1',           // 区 (例: 東京都千代田区)
                'sublocality_level_2',           // 〇〇町
                'sublocality_level_3',           // 〇〇丁目
                'sublocality_level_4'            // 番地など
            ];

            const addressParts = [];
            for (const type of desiredTypes) {
                const component = addressComponents.find(c => c.types.includes(type));
                if (component && !addressParts.includes(component.long_name)) {
                    addressParts.push(component.long_name);
                }
            }

            // 連結した結果が空なら、元のformattedAddressを返す
            return addressParts.length > 0 ? addressParts.join('') : formattedAddress;
        }

        /**
         * 指定された座標を逆ジオコーディングし、結果を分析して最適な地名を出発地として設定します。
         * 施設名があればそれを優先し、なければ住所を設定します。
         * @param {google.maps.LatLng} location - 出発地として設定する座標
         */
        async function setOriginToGeocodedLocation(location) {
            if (!location) return;

            originLatLng = location;

            try {
                const { results } = await geocoder.geocode({ location: location, language: currentLang });
                if (results && results.length > 0) {
                    // 最初の結果の住所を整形して使用する
                    originInput.value = formatAddress(results[0].formatted_address, results[0].address_components);
                }
            } catch (e) {
                console.error("Geocoding failed for new origin:", e);
            }
        }

        // モジュールスコープ内の関数をグローバルに公開して、Google Mapsのコールバックから呼び出せるようにする
        window.initMap = initMap;

        async function initMap() {
            // URLからMap IDを取得
            const urlParams = new URLSearchParams(window.location.search);
            const mapId = urlParams.get('mapId');

            map = new google.maps.Map(document.getElementById('map'), {
                center: initialLocation,
                zoom: 12,
                disableDefaultUI: true,
                streetViewControl: false, // ストリートビューのペグマンを非表示
                mapTypeControl: true,    // デフォルトのマップ/航空写真コントロールを非表示
                // Map IDが指定されていれば、ベクターマップとして初期化
                ...(mapId && { mapId: mapId, tilt: 45, heading: 0 }),
                // ラスターマップ用の設定（Map IDがない場合）
                ...(!mapId && { mapTypeId: 'roadmap' }),
                zoomControl: true,
                fullscreenControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                    //style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                    position: google.maps.ControlPosition.LEFT_TOP // 新しい位置を指定
                },
                zoomControlOptions: { //ズーム コントロール
                    position: google.maps.ControlPosition.RIGHT_BOTTOMC,
                },
            });

            // Map IDが指定され、正常に読み込めたかを確認、作成時のtiltが反映されているかでベクターマップと判断する
            if (mapId && map.mapId === mapId && map.tilt === 45) {
                map.setTilt(0); // 判断に使った４５度を解除
                isVectorMap = true;
                console.log('Vector map enabled with Map ID:', mapId);
                // 「進行方向を上に」のラベルを「チルト表示」に変更
                const tiltViewLabel = document.getElementById('tilt-view-label');
                if (tiltViewLabel) {
                    tiltViewLabel.parentElement.style.display = 'flex'; // チルト表示のitemを表示
                }
            } else {
                const tiltViewLabel = document.getElementById('tilt-view-label');
                if (tiltViewLabel) tiltViewLabel.parentElement.style.display = 'none'; // チルト表示のitemを非表示
                isVectorMap = false;
                console.log('Raster map enabled (No valid Map ID provided or failed to load).');
            }

            // --- TTSエンジンの初期化 ---
            // URLパラメータからAPIキーを取得
            const apiKey = urlParams.get('apiKey');

            let isVvoxAvailable = false;
            if (apiKey) {
                // APIキーがあればWeb版APIを使用
                console.log("Using VOICEVOX Web API with provided key.");
                vvoxEngine = new VoiceVoxWebApi();
                isVvoxAvailable = await vvoxEngine.initialize(apiKey);
            } else {
                // APIキーがなければローカルエンジンを試す
                console.log("No API key found, trying to connect to local VOICEVOX engine.");
                vvoxEngine = new VVoxEngine();
                isVvoxAvailable = await vvoxEngine.initialize();
            }

            if (isVvoxAvailable) {
                try {
                    const speakers = await vvoxEngine.getSpeakers();
                    voiceSelect.innerHTML = ''; // 既存の選択肢をクリア
                    speakers.forEach(speaker => {
                        speaker.styles.forEach(style => {
                            const option = document.createElement('option');
                            option.value = style.id;
                            option.textContent = `${speaker.name} (${style.name})`;
                            voiceSelect.appendChild(option);
                        });
                    });
                    voiceSelect.disabled = false;
                    // 保存されたVOICEVOX話者IDを選択
                    const savedSpeakerId = localStorage.getItem('vvoxSpeakerId');
                    if (savedSpeakerId) {
                        voiceSelect.value = savedSpeakerId;
                        // setSpeakerIdを呼び出してエンジンに話者IDを設定
                        vvoxEngine.setSpeakerId(savedSpeakerId);
                    } else if (speakers.length > 0 && speakers[0].styles.length > 0) {
                        // デフォルトの話者を設定
                        vvoxEngine.setSpeakerId(savedSpeakerId);
                    }
                } catch (error) {
                    console.error("Failed to load VOICEVOX speakers:", error);
                    populateVoiceList(); // VOICEVOX話者取得失敗時はOS標準に戻す
                }
            } else {
                // VOICEVOXが利用できない場合は、OS標準の音声リストを読み込む
                populateVoiceList();
                if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = populateVoiceList;
                }
            }
            // 以下の初期化はmapオブジェクトが生成された後に行う
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({ map: map, suppressMarkers: true });
            elevationService = new google.maps.ElevationService();
            geocoder = new google.maps.Geocoder();
            streetViewService = new google.maps.StreetViewService();

            // localStorageからホーム地点を読み込み、設定する
            const savedHome = localStorage.getItem('streetMoViewHomeLocation');
            if (savedHome) {
                try {
                    const homeCoords = JSON.parse(savedHome);
                    if (homeCoords && typeof homeCoords.lat === 'number' && typeof homeCoords.lng === 'number') {
                        initialLocation = homeCoords;
                        map.setCenter(initialLocation);
                        // 新しい関数を使って出発地を設定
                        await setOriginToGeocodedLocation(new google.maps.LatLng(homeCoords.lat, homeCoords.lng));
                    }
                } catch (e) {
                    console.error("Failed to parse or geocode home location from localStorage", e);
                    localStorage.removeItem('streetMoViewHomeLocation');
                }
            }

            // 地図上に検索ボックスを作成して配置
            const searchInput = document.createElement('input');
            mapSearchInput = searchInput;
            searchInput.id = 'pac-input';
            searchInput.type = 'text';
            searchInput.placeholder = '場所を検索';
            searchInput.style.cssText = 'background-color: #fff; font-family: Roboto; font-size: 15px; font-weight: 300; margin: 10px 0 10px 10px; padding: 5px 10px; width: 300px; border: 1px solid #ccc; box-shadow: 0 2px 6px rgba(0,0,0,0.3); border-radius: 3px;';
            
            const searchBox = new google.maps.places.SearchBox(searchInput);
            map.controls[google.maps.ControlPosition.TOP_LEFT].push(searchInput);

            // 検索ボックスのプレースホルダーを初期設定
            searchInput.placeholder = uiStrings[currentLang].searchForPlace;
            panorama = new google.maps.StreetViewPanorama(document.getElementById('street-view'), {
                position: initialLocation,
                visible: true,
                pov: { heading: 0, pitch: 0, zoom: 1 },
                source: google.maps.StreetViewSource.DEFAULT // 初期状態ではユーザー投稿も表示
            });

            map.setStreetView(panorama);

            // SearchBoxで場所が選択されたときのリスナー
            streetViewCoverageLayer = new google.maps.StreetViewCoverageLayer();

            // SearchBoxで場所が選択されたときのリスナー
            // カスタムのマップタイプコントロールを先に有効にする
            map.setOptions({ mapTypeControl: true });

            // マップ左下のコントロールを配置
            const mapControlsContainer = document.getElementById('map-controls-container');
            map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(mapControlsContainer);

            mapControlsContainer.style.display = 'flex'; // 表示を有効にする

            searchBox.addListener('places_changed', () => {
                const places = searchBox.getPlaces();

                if (places.length == 0) {
                    return;
                }

                // 最初の場所を取得してジャンプ
                jumpToPlace(places[0]);
            });

            // POIクリックで情報ウィンドウを表示し、出発地/目的地に設定する機能
            placesService = new google.maps.places.PlacesService(map);
            infoWindow = new google.maps.InfoWindow({
                // InfoWindow内のコンテンツがはみ出ないように最大幅を設定
                maxWidth: 350
            });

            map.addListener('click', (e) => {
                // クリックした場所に既にInfoWindowが開いていたら閉じる
                infoWindow.close();
                selectedPlace = null;

                if (e.placeId) {
                    e.stop(); // デフォルトのPOI情報ウィンドウの表示を停止

                    placesService.getDetails({ placeId: e.placeId }, (place, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && place && place.geometry && place.geometry.location) {
                            selectedPlace = place; // クリックされた場所の情報を保持

                            // 出発地が入力されているかチェック
                            const isOriginSet = originInput.value.trim() !== '' || originLatLng !== null;
                            const setDestButtonText = isOriginSet ? uiStrings[currentLang].setAsDestinationAndSearch : uiStrings[currentLang].setAsDestination;
                            const setDestButtonId = isOriginSet ? 'set-dest-and-search-btn' : 'set-dest-btn';

                            // 出発地が設定されていれば、直線距離を計算して表示
                            let distanceInfoHtml = '';
                            if (originLatLng) {
                                const distanceInMeters = google.maps.geometry.spherical.computeDistanceBetween(originLatLng, place.geometry.location);
                                const distanceInKm = (distanceInMeters / 1000).toFixed(2);
                                distanceInfoHtml = `<div style="font-size: 12px; color: #777; margin-top: 8px;">現在地からの直線距離: 約 ${distanceInKm} km</div>`;
                            }

                            // ログ記録中でなければ「ここへ移動」ボタンを表示する
                            const setOriginButtonHtml = !isLogging
                                ? `<button class="infowindow-btn" id="set-origin-btn">${uiStrings[currentLang].setAsOrigin}</button>`
                                : '';

                            // InfoWindowに表示するHTMLコンテンツを生成
                            const content = `
                                <div style="color: #333; font-family: 'Inter', sans-serif; line-height: 1.5;">
                                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 4px;">${place.name}</div>
                                    ${place.formatted_address ? `<div style="font-size: 13px; color: #555; margin-bottom: 12px;">${place.formatted_address}</div>` : ''}
                                    ${distanceInfoHtml}
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px;">
                                        ${setOriginButtonHtml}
                                        <button class="infowindow-btn" id="${setDestButtonId}">${setDestButtonText}</button>
                                        <button class="infowindow-btn" id="set-home-btn" style="background-color: #27ae60;">${uiStrings[currentLang].setAsHome}</button>
                                    </div>
                                </div>
                            `;
                            infoWindow.setContent(content);
                            infoWindow.setPosition(e.latLng);
                            infoWindow.open(map);

                            // ストリートビューの位置をクリックした場所に更新
                            panorama.setPosition(place.geometry.location);
                        }
                    });
                }
            });

            // InfoWindow内のボタンにイベントリスナーを設定
            infoWindow.addListener('domready', () => {
                document.getElementById('set-origin-btn')?.addEventListener('click', () => {
                    if (selectedPlace && selectedPlace.geometry && selectedPlace.geometry.location) {
                        // POIクリック時は、まず場所の名前(place.name)を優先して使う
                        // これにより「東京駅」のような短い名前が表示される
                        const displayName = selectedPlace.name || selectedPlace.formatted_address;
                        if (displayName) {
                            originInput.value = displayName;
                            if (mapSearchInput) {
                                mapSearchInput.value = displayName;
                            }
                        } else {
                            // 名前がない場合は逆ジオコーディングで住所を取得
                            setOriginToGeocodedLocation(selectedPlace.geometry.location);
                        }

                        originLatLng = selectedPlace.geometry.location;
                        jumpToPlace(selectedPlace);
                        infoWindow.close();
                    }
                });
                document.getElementById('set-dest-btn')?.addEventListener('click', () => {
                    if (selectedPlace) {
                        destinationInput.value = selectedPlace.name || selectedPlace.formatted_address;
                        destinationLatLng = selectedPlace.geometry.location;
                        infoWindow.close();
                    }
                });
                document.getElementById('set-dest-and-search-btn')?.addEventListener('click', () => {
                    if (selectedPlace) {
                        destinationInput.value = selectedPlace.name || selectedPlace.formatted_address;
                        destinationLatLng = selectedPlace.geometry.location;
                        infoWindow.close();
                        // 即座に経路検索を実行
                        calculateAndDisplayRoute();
                    }
                });
                document.getElementById('set-home-btn')?.addEventListener('click', () => {
                    if (selectedPlace && selectedPlace.geometry && selectedPlace.geometry.location) {
                        const homeLocation = {
                            lat: selectedPlace.geometry.location.lat(),
                            lng: selectedPlace.geometry.location.lng()
                        };
                        // ホーム地点をlocalStorageに保存
                        localStorage.setItem('streetMoViewHomeLocation', JSON.stringify(homeLocation));
                        showMessage(uiStrings[currentLang].homeSet, false);
                        infoWindow.close();
                    }
                });
            });

            // 出発地・目的地のオートコンプリート設定
            const autocompleteOptions = {
                fields: ["geometry", "name", "formatted_address"],
                types: ["geocode", "establishment"],
            };
            originAutocomplete = new google.maps.places.Autocomplete(originInput, autocompleteOptions);
            destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput, autocompleteOptions);

            originAutocomplete.addListener('place_changed', () => {
                originLatLng = originAutocomplete.getPlace()?.geometry?.location || null;
            });
            destinationAutocomplete.addListener('place_changed', () => {
                destinationLatLng = destinationAutocomplete.getPlace()?.geometry?.location || null;
            });

            const elevationChartCanvas = document.getElementById('elevation-chart');
            elevationChartCanvas.addEventListener('click', handleChartClick);

            routeButton.addEventListener('click', calculateAndDisplayRoute);
            toggleTourButton.addEventListener('click', toggleTour);
            bleConnectButton.addEventListener('click', connectToBleDevice);
            boostButton.addEventListener('click', () => { /* イベントリスナーは既に設定済み */ });
            logToggleButton.addEventListener('click', toggleLogging);
            hrConnectButton.addEventListener('click', connectToHrDevice);

            // 言語スイッチャーのイベントリスナー
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setLanguage(e.target.dataset.lang);
                });
            });

            // ストリートビューカバレッジのトグルスイッチ
            const svCoverageToggle = document.getElementById('sv-coverage-toggle');
            svCoverageToggle.addEventListener('change', (event) => {
                streetViewCoverageLayer.setMap(event.target.checked ? map : null);
            });

            // ユーザー投稿データ表示のトグルスイッチ
            const userContentToggle = document.getElementById('user-content-toggle');
            userContentToggle.addEventListener('change', (event) => {
                showUserContent = event.target.checked;
                // panoramaのsourceを更新して即時反映
                panorama.setOptions({ source: showUserContent ? google.maps.StreetViewSource.DEFAULT : google.maps.StreetViewSource.OUTDOOR });
            });

            // 進行方向を上にするトグルスイッチ
            const tiltViewToggle = document.getElementById('tilt-view-toggle');
            tiltViewToggle.addEventListener('change', (event) => {
                if (isVectorMap) {
                    // ベクターマップの場合：チルト表示の切り替え
                    isTiltView = event.target.checked;
                    map.setTilt(isTiltView ? 60 : 0);
                    // チルト表示、現在の進行方向に地図の向きを反映させる
                    const heading = (isTiltView && currentPointIndex + 1 < routePoints.length) ?
                        getHeading(routePoints[currentPointIndex], routePoints[currentPointIndex + 1]) : 0;
                    map.setHeading(heading);
                }
            });

            // タブが再度表示されたときにWake Lockを再取得する
            document.addEventListener('visibilitychange', async () => {
                if (isTourRunning && document.visibilityState === 'visible') {
                    await requestWakeLock();
                }
            });

            // 手動での速度変更を検知
            speedInput.addEventListener('input', () => {
                manualSpeedKmh = parseFloat(speedInput.value) || 0;
                if (!isTourRunning && !bleDevice?.gatt.connected) actualSpeedKmh = manualSpeedKmh;
                // 速度の変更はtourStepループ内で自動的に反映される
            });

            [originInput, destinationInput].forEach(input => {
                input.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        calculateAndDisplayRoute();
                    }
                });
            });

            // ユーザーが手動で入力した場合、保存されたLatLngをクリアする
            originInput.addEventListener('input', () => {
                originLatLng = null;
            });
            destinationInput.addEventListener('input', () => {
                destinationLatLng = null;
            });

            const splitter = document.getElementById('splitter');
            const mapDiv = document.getElementById('map');
            const streetViewDiv = document.getElementById('street-view');
            const splitContainer = document.getElementById('split-container');
            let isDragging = false;
            let startPos;
            let startSize;

            streetViewDiv.style.flexGrow = '0';
            mapDiv.style.flexGrow = '0';

            const initialRatio = 0.7;
            const isMobile = window.innerWidth <= 767;
            if (isMobile) {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetHeight * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetHeight * (1 - initialRatio)}px`;
            } else {
                streetViewDiv.style.flexBasis = `${splitContainer.offsetWidth * initialRatio}px`;
                mapDiv.style.flexBasis = `${splitContainer.offsetWidth * (1 - initialRatio)}px`;
            }

            splitter.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
                document.body.style.cursor = isMobile ? 'row-resize' : 'col-resize';
                mapDiv.style.transition = 'none';
                streetViewDiv.style.transition = 'none';
                if (isMobile) {
                    startPos = e.clientY;
                    startSize = streetViewDiv.offsetHeight;
                } else {
                    startPos = e.clientX;
                    startSize = streetViewDiv.offsetWidth;
                }
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging) return;
                isDragging = false;
                document.body.style.cursor = 'default';
                mapDiv.style.transition = 'flex 0.3s ease';
                streetViewDiv.style.transition = 'flex 0.3s ease';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = splitContainer.getBoundingClientRect();
                const minSize = 100;
                let newSize;
                if (isMobile) {
                    const delta = e.clientY - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.height - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.height - newSize}px`;
                } else {
                    const delta = e.clientX - startPos;
                    newSize = startSize + delta;
                    newSize = Math.max(minSize, Math.min(newSize, rect.width - minSize));
                    streetViewDiv.style.flexBasis = `${newSize}px`;
                    mapDiv.style.flexBasis = `${rect.width - newSize}px`;
                }
            });
        }

        function loadMapsScript() {
            if (window.google && window.google.maps) {
                initMap();
                return;
            }

            // Google Maps APIキーが無効だった場合に呼び出されるコールバック
            window.gm_authFailure = function() {
                console.error("Google Maps API key authentication failed. Clearing the stored key.");
                // 保存されている無効なAPIキーを削除
                localStorage.removeItem('streetMoViewApiKey');
                // ページをリロードして、再度キー入力を促す
                location.reload();
            };

            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap&libraries=places,geometry`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        function disableApiDependentFeatures(disabled) {
            routeButton.disabled = disabled;
            loadGpxButton.disabled = disabled;
            // 他のAPI依存機能があればここに追加
        }

        let GOOGLE_MAPS_API_KEY = localStorage.getItem('streetMoViewApiKey');
        let initialLocation = { lat: 35.681236, lng: 139.767125 }; // デフォルト: 東京駅

        // APIキーを読み込む前に、まずlocalStorageからホーム位置を読み込んでおく
        // これにより、APIキー入力プロンプトが表示される前に地図の中心位置が決まる
        const savedHomeBeforeApi = localStorage.getItem('streetMoViewHomeLocation');
        if (savedHomeBeforeApi) {
            try {
                const homeCoords = JSON.parse(savedHomeBeforeApi);
                if (homeCoords && typeof homeCoords.lat === 'number' && typeof homeCoords.lng === 'number') {
                    initialLocation = homeCoords;
                }
            } catch (e) { /* パース失敗時はデフォルト値を使用 */ }
        }

        window.addEventListener('DOMContentLoaded', () => {
            fullscreenButton = document.getElementById('fullscreen-button');
            fullscreenButton.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButtonState);

            // 初期速度を設定
            speedInput.value = defaultSettings[currentTravelMode].speed;
            manualSpeedKmh = defaultSettings[currentTravelMode].speed;

            // --- 保存された設定を読み込む ---
            const savedVoiceEnabled = localStorage.getItem('isVoiceGuidanceEnabled');
            if (savedVoiceEnabled !== null) {
                isVoiceGuidanceEnabled = (savedVoiceEnabled === 'true');
            }
            voiceGuidanceToggle.checked = isVoiceGuidanceEnabled;

            const savedGeocodeInterval = localStorage.getItem('geocodeIntervalDistance');
            if (savedGeocodeInterval !== null) {
                geocodeIntervalDistance = parseInt(savedGeocodeInterval, 10);
            }
            geocodeIntervalInput.value = geocodeIntervalDistance;

            const savedThreshold = localStorage.getItem('autoBoostThreshold');
            if (savedThreshold !== null) {
                autoBoostThreshold = parseInt(savedThreshold, 10);
            }
            autoBoostThresholdInput.value = autoBoostThreshold;
            // ---------------------------------

            setLanguage(currentLang); // ★最初に言語を設定

            let GOOGLE_MAPS_API_KEY = localStorage.getItem('streetMoViewApiKey');

            if (!GOOGLE_MAPS_API_KEY) {
                const promptMessages = {
                    ja: 'このアプリケーションを利用するにはGoogle Maps APIキーが必要です。\nAPIキーを入力してください。キーはブラウザに保存され、外部には送信されません。',
                    en: 'A Google Maps API Key is required to use this application.\nPlease enter your API key. It will be stored in your browser and will not be sent externally.'
                };
                GOOGLE_MAPS_API_KEY = prompt(promptMessages[currentLang]);
                if (GOOGLE_MAPS_API_KEY && GOOGLE_MAPS_API_KEY.trim() !== '') {
                    localStorage.setItem('streetMoViewApiKey', GOOGLE_MAPS_API_KEY);
                    // キーを保存したらリフレッシュしてAPIスクリプトを読み込ませる
                    location.reload();
                    return; // リフレッシュするので以降の処理は不要
                } else {
                    // キーが入力されなかった場合はブランクページに移動
                    //window.location.href = 'about:blank';
                    // 代わりにメッセージを表示する改善案
                    document.body.innerHTML = '<h1>Google Maps API Key is required. Please reload and enter your key.</h1>';
                    return;
                }
            }
            
            if (GOOGLE_MAPS_API_KEY) {
                loadMapsScript();
            } else {
                // このケースはlocalStorageにキーがなく、promptもキャンセルされた場合に到達する
                window.location.href = 'about:blank';
            }
        });
    </script>

</body>
</html>
